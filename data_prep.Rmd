---
title: "Les communes nouvelles françaises (2012-2021) : réalisation d'une base de données"
author: "Auteur anonymisé"
date: '`r format(Sys.Date(), "%d %B %Y")`'
output:
     # html_document:
     # toc: true
     # theme: united
    word_document:
         reference_docx: css/stylesCybergeo.docx # Si export en word
bibliography: biblio/Datapaper.bib
csl: https://journals.openedition.org/cybergeo/32003?file=1 # ou biblio/cybergeo14032018.csl

# editor_options: 
#   chunk_output_type: console
nocite: '@*' # permet que toutes les références de la bibliographie soient citées, même sans appel dans le texte
# Pour désanonymiser, remplacer _Auteur anonymisé_ par _Noms auteurs_

# Tu ne peux pas citer des réf en bibklio non citées dans le texte

---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, # Afficher ou non le code R dans le document
                      eval	= TRUE, #	Exécuter ou non le code R à la compilation
                      include	= TRUE, #	Inclure ou non le code R et ses résultats dans le document
                      # results	“hide”/“asis”/“markup”/“hold”	Type de résultats renvoyés par le bloc de code
                      warning = FALSE, # Afficher ou non les avertissements générés par le bloc
                      message = FALSE, # Afficher ou non les messages générés par le bloc
                      cache = TRUE) # Utiliser le cache pour accélerer les knits.

# Librairies utiles
library(sf)
library(cartography)
library(mapsf)
library(readxl) # Pour import .xls
library(foreign) # Pour import .dbf
library(dplyr) # Pour l'agrégation des données
library(flextable) # Pour la création de tableaux

```

# Mots-clés
commune, commune nouvelle, fusion de données, bases de données, France


# Introduction

Depuis 2012, plusieurs centaines de communes françaises ont fusionné au sein de "communes nouvelles" [@bideau2019]. Ces regroupements sont très minoritaires mais loin d'être anecdotiques sur l'ensemble des communes françaises : entre 2012 et le 1^er^ janvier 2021, 2517 communes (soit 7% des communes françaises) ont contribué à la création de 778 communes nouvelles, représentant 3,4% de la population française. Surtout, la création de ces nouvelles entités pose un certain nombre de problèmes lorsqu'il s'agit de traiter des données statistiques faisant référence aux communes. Si les dimensions juridiques [@aubelle2016 ; @lenfant2018 ; @verpeaux2016] ou politiques [@frinault2017 ; @kada2017; @pasquier2017 ; @ville2017] ont pu être considérablement bien présentées, une analyse plus fine et quantitative du phénomène des communes nouvelles ([Référence anonymisée]) a nécessité la création d'une base de donnée spécifique.


Les données fournies par l'INSEE (Institut National de la Statistique et des Études Économiques) sont facilement exploitables pour étudier une situation à une année donnée mais rendent malaisée l'étude des regroupements. La base de donnée qui est présentée ici et le code qui y est associé ont pour but initial de permettre un travail d'analyse du phénomène de fusions en communes nouvelles.

Certains outils existent pour gérer l'évolution des codes officiels géographiques. Le plus pertinent est sans doute le package `COGugaison`, construit pour le langage R par Kim Antunez [@antunez2017]. Ce dernier propose, à sa manière, des fonctionnalités qui auraient pu être utilisées pour construire la présente base de donnée. Cependant, il a été publié à partir de 2017, soit après le début de nos recherches sur les communes nouvelles et la réalisation de notre base de données. D'autre part, son utilisation pour les données les plus récentes dépend de sa mise à jour par l'auteur du package. Enfin, ce package est un outil pertinent mais qui ne propose pas, en tant que tel, de base de données. 

Nous avons donc élaboré, à partir des données issues de la statistique publique, une base permettant l'analyse du phénomène des communes nouvelles. Nous verrons que sa construction fait partie intégrante de la démarche heuristique dans le but de mieux appréhender l'objet d'étude que sont les communes nouvelles. Il a fallu, pour cela, non seulement gérer l'identification des entités territoriales à différentes dates mais aussi agréger les données en fonction de leur nature. Les procédés utilisés pourront aisément être reproduits sur d'autres cas de fusions. En effet, la reconfiguration des territoires est un phénomène qui se retrouve à de multiples échelles, et bien plus largement que dans le cas français [@comiteeuropeensurlademocratielocaleetregionalecdlr2007 ; @vanier2002]. Les conséquences des régions françaises suite à la loi NOTRe de 20015 a par exemple déjà été étudiée [@dore2021 ; @dumont2018] mais les possibilités d'analyses sont loin d'être épuisées.

Nous présenterons tout d'abord les objectifs généraux de la réalisation de cette base de donnée, puis les données disponibles, avant de détailler les méthodes mises en œuvre et d'esquisser quelques traitements rendus possibles par cette base.

# 1 - Objectifs généraux
Les communes françaises sont identifiées par l'INSEE via un code théoriquement unique (le "CODGEO"), constitué de cinq chiffres dont les deux premiers (ou trois pour l'outre-mer) reprennent le numéro du département concerné. À un instant *t*, chaque CODGEO ne fait référence qu'à une seule commune, c'est de ce point de vue un identifiant unique.

Cette unicité n'est cependant pas complètement valable dans le temps : outre quelques très rares cas de changements de CODGEO (un exemple typique étant la commune de l'Oudon, dans le Calvados, cf. plus bas), lors des fusions, l'INSEE a choisi de donner à la nouvelle entité le code de la commune qui en devient le chef-lieu. Ce procédé, qui permet de ne pas avoir à créer des CODGEO à l'infini pose un problème sérieux si on fusionne des données de différentes années puisque les séries statistiques risquent d'être perturbées par les changements de périmètres.

À partir des données INSEE et le fond géographique de référence aux géographies du 1^er^ janvier 2011 (avant toute création de commune nouvelle), il s'agit de structurer la base de données pour qu'elle comporte :

* Les géométries de référence au 1^er^ janvier 2011 et au 1^er^ janvier de l'année la plus récente pour laquelle des données ont été publiées par l'INSEE avec le même niveau de généralisation cartographique. Ces objets seront appelés respectivement `geom2011` et  `geom_new`. 
* Les géométries des communes qu'on nommera fusionnantes[^fusionnantes], soit avant les fusions, au 1^er^ janvier 2011 (`geomfus2011`) et après les fusions, à la date la plus récente connue (`geomCN_new`). 
* Des données statistiques contextuelles pour l'ensemble des communes existant en 2011, regroupées dans l'objet `df2011`. Ces données sont d'ordre socio-économique (emploi, structure par âge, etc.), relatives à des zonages (EPCI d'appartenance, catégories d'aires urbaines), et plus important, celles permettant de décrire la nature des fusions communales à l'œuvre.
* Ces mêmes données statistiques (donc les plus récentes qui aient été publiées à la géographie administrative de 2011, avant la création de toute commune nouvelle), sont agrégées en fonction de leur nature (stock, ratio, valeurs textuelles) pour constituer l'objet `df_new`, qui reprend la géographie administrative la plus récente (ici 2021).

[^fusionnantes]: Nous désignons ainsi les communes ayant participé à la fusion, c'est-à-dire les communes historiques ; le terme de « commune nouvelle », inscrit dans la loi, désigne la nouvelle entité, après la fusion.

La jointure entre les données et les géométries de référence est évidemment facilitée pour permettre cartographie et analyse spatiale.

![**Schéma général de la construction de la base de donnée**](figures/Schema_BdD.png)

Le présent *data paper*, lisible ici sous forme de texte, est issu d'un RMarkdown mis librement à disposition et comportant la totalité des lignes de code nécessaires à la reproduction de la démarche (ces dernières sont ici masquées pour faciliter la lecture).

# 2 - Présentation des sources
Les statistiques publiques françaises sont aujourd'hui massivement accessibles, globalement fiables et bien documentées. Nous avons donc décidé de nous appuyer sur ces dernières : principalement l'IGN (Institut Géographique National) pour les géométries de référence nécessaires (2.1) et l'INSEE pour les données statistiques (2.2) ainsi que celles permettant de documenter les fusions de communes (2.3).


## 2.1 - Les géométries de référence
L'IGN propose des données multiples, dont un fond géographique à l'échelle des communes. Nous avons utilisé le fond [Geofla®Communes édition 2011 (France Métropolitaine)](https://geoservices.ign.fr/documentation/diffusion/telechargement-donnees-libres.html#geofla) puisque l'année 2011 est la dernière avant toute création de commune.


## 2.2 - Les données contextuelles statistiques : Fichiers sources et indicateurs cibles
Afin de caractériser les spécificités des communes nouvelles, plusieurs tables statistiques à l'échelon communal sont disponibles. Nous souhaitions pouvoir étudier l'ensemble des communes nouvelles, ce qui impliquait de prendre comme point de départ la géographie administrative au 1^er^ janvier 2011. Or, lorsque l'INSEE publie des données, le millésime annoncé est souvent différent de la géographie administrative utilisée (ce qui est précisé dans les métadonnées). Ainsi, les tables que nous avons utilisées sont généralement le millésime 2009 pour la géographie administrative au 1^er^ janvier 2011.

La table suivante résume les indicateurs que nous avons ciblés pour la collecte de données. Ils constituent généralement des numérateurs et dénominateurs qui pourront, par la suite, être composés en ratios. 

Ces données sont accessibles sur les sites des institutions concernées à partir du nom du jeu de données présent dans la table ci-dessous (le lien précis est indiqué dans le fichier meta.xlsx).    

```{r stat_target, echo = FALSE}

target <- as.data.frame(read_excel("data-raw/meta.xlsx", sheet = "ind_target"))

# knitr::kable(target[,c("INSEE_CODE","DESCRIPTION", "SOURCE", "PRODUCTEUR")], row.names = F, digits = 1) # Pour export html
ft <- flextable(target[,c("INSEE_CODE","DESCRIPTION", "SOURCE", "PRODUCTEUR")])
ft <- width(ft, width = 1.7)
ft
```

## 2.3 - Données concernant les fusions communales et les communes nouvelles
La [table de passage communale](https://www.insee.fr/fr/information/2028028) produite par l'INSEE restitue l'ensemble des changements qui ont touché des communes en France depuis 2003. Cette table ne concerne pas exclusivement les communes nouvelles.

Pour cette raison, nous avons associé à ce fichier d'origine d'autres tables mises à disposition par l'INSEE : la liste des communes nouvelles ([un fichier par année depuis 2016](https://www.insee.fr/fr/information/2549968)). Ces dernières comportent, pour chaque commune ayant participé à une fusion, les informations avant et après ce changement, ainsi que la date de décision et d'effet[^tablepassage]. Pour récupérer les créations de communes nouvelles antérieures au 2 janvier 2015, un fichier a été créé à partir de l'interface d'[historique des communes](https://www.insee.fr/fr/metadonnees/historique-commune?taille=100&debut=0&modification=MG&p-debut=2003&p-fin=2014) de l'INSEE.

[^tablepassage]: Les tables de passages de l'INSEE comprennent les fusions du 2 janvier de l'année indiquée jusqu'au 1^er^ janvier de l'année suivante, inclus. Par exemple, la première table de passage, publiée en 2016 et appelée table de passage "2015" comprend toutes les fusions du 2 janvier 2015 au 1^er^ janvier 2016.

Le tableau suivant présente le récapitulatif des informations mises à disposition par l'INSEE : 

```{r changes, echo = FALSE}

tab <- as.data.frame(read_excel("data-raw/meta.xlsx", sheet = "tab_passage"))

# knitr::kable(tab, row.names = F) # Pour export html
ft <- flextable(tab)
ft <- width(ft, width = 1.7)
ft
```



# 3 - Les méthodes mises en œuvre
Nous allons détailler ici les étapes réalisées pour importer, préparer, agréger et exporter l'ensemble des données nécessaires à l'analyse du phénomène des communes nouvelles.

## 3.1 - Import des géométries de référence
Le fond géographique [Geofla®Communes édition 2011 France Métropolitaine](https://geoservices.ign.fr/telechargement#geofla) a d'abord été importé, c'est l'objet `geom2011`. Les arrondissements marseillais, lyonnais et parisiens ont été agrégés au niveau communal pour un meilleur appariement avec les données statistiques de référence utilisées ultérieurement. Les communes de Corse ont également été supprimées, étant donné (1) qu'elles ne sont pas concernées par le processus de création de communes nouvelles et (2) que cela permet d'améliorer la résolution et simplicité des représentations cartographiques.

Ce fond communal a ensuite été agrégé au niveau des départements pour permettre des cartographies plus lisibles, c'est l'objet `dep`.

Nous avons finalement extrait le code communal de ces géométries, ce dernier servant de référence pour les jointures ultérieures avec les données attributaires. 

```{r geom2011, include = FALSE}

# Géométries des communes françaises au 1er janvier 2011 (source : IGN)
geom2011 <- st_read(dsn = "data-raw/geom/COMMUNE.shp")
geom2011 <- geom2011[geom2011$CODE_REG != "94",] # Suppression de la Corse
geom2011 <- st_transform(geom2011, crs = 3035) # Transformation Lambert-93


# Suppression et regroupement des arrondissements de Paris, Lyon et Marseille
arrcom <- read_excel("data-raw/geom/com_arm.xlsx") # Import de la table de passage des arrondissements
com <- merge(geom2011, arrcom, by = "INSEE_COM", all.y = TRUE) # Géométries des arrondissements
com <- aggregate(x = com[,"CODGEO"], by = list(com$CODGEO), # On les aggrège
                   FUN = head, 1)

com$NOM_COMM <- c("MARSEILLE", "LYON", "PARIS")
com$CODE_DEPT <- c("13","69","75")

geom2011 <- geom2011[!geom2011$INSEE_COM %in% arrcom$INSEE_COM, ] # Suppression des arrondissements

colnames(geom2011)[3] <- "CODGEO"
geom2011 <- rbind(geom2011[,c("CODGEO","NOM_COMM", "CODE_DEPT")],
                  com[,c("CODGEO","NOM_COMM", "CODE_DEPT")])


# Agrégation en départements
dep <-  aggregate(x = geom2011[,"CODE_DEPT"], by = list(geom2011$CODE_DEPT), # Agrégation des communes en départements
                   FUN = head, 1)

# Création d'un data frame avec les CODGEO de référence
df <- st_set_geometry(geom2011[,c("CODGEO", "CODE_DEPT")], NULL)

# Forcer character
df$CODGEO <- as.character(df$CODGEO)
df$CODE_DEPT <- as.character(df$CODE_DEPT)

```




## 3.2 - Préparation des données statistiques
Il a ensuite fallu importer les indicateurs contenus dans les tables de référence, réaliser une jointure avec les codes communaux 2011 et filtrer les indicateurs pour ne conserver que les indicateurs d'intérêt. Le tout a été inclus dans un objet `df2011`, regroupant donc les données contextuelles d'intérêt pour cette étude, aux géographies du 1^er^ janvier 2011. 

```{r data_import}

# Importer les tableaux de données d'intérêt
datatmp1 <- data.frame(read_excel("data-raw/stats_insee/base-cc-emploi-pop-active-2009.xls", sheet = "COM_2009", skip = 5))
datatmp2 <- data.frame(read_excel("data-raw/stats_insee/base-cc-evol-struct-pop-2009.xls", sheet = "COM_2009", skip = 5))
datatmp3 <- data.frame(read_excel("data-raw/stats_insee/BTX_FM_DTR_2009.xls", sheet = "TOTAL", skip = 5))
datatmp4 <- data.frame(read_excel("data-raw/stats_insee/Potentiel_financier_2011.xls", sheet = "Rapport1", skip = 2))
datatmp5 <- data.frame(read_excel("data-raw/stats_insee/table-appartenance-geo-communes-11.xls", sheet = "Liste_COM", skip = 5))
datatmp6 <- read.csv("data-raw/stats_insee/city_all.csv", sep = ",", stringsAsFactors = FALSE, fileEncoding = "UTF8")
datatmp6 <- subset(datatmp6, datatmp6$année == "2011")

# Nécessité d'une procédure un peu plus longue pour les données concernant les revenus
sheet_names <- excel_sheets("data-raw/stats_insee/Ircom_2011_revenus2010.xls") # On liste les feuilles
datatmp7 <- data.frame()
for (i in 1:length(sheet_names)){
  feuille <- sheet_names[i] # récupère le nom de la feuille
  IRFeuille <- data.frame(read_excel("data-raw/stats_insee/Ircom_2011_revenus2010.xls", sheet = feuille, skip = 20))
  datatmp7 <- rbind(datatmp7, IRFeuille, stringsAsFactors = FALSE)
  rm(feuille, IRFeuille) # suppression des objet intermédiaires
}
# Renommer variables
colnames(datatmp7)[10] <- "Traitements.et.salaires_Nbr.foyers"
colnames(datatmp7)[11] <- "Traitements.et.salaires_Montant"
colnames(datatmp7)[12] <- "Retraites.et.pensions_Nbr.foyers"
colnames(datatmp7)[13] <- "Retraites.et.pensions_Montant"
datatmp7 <- subset(datatmp7, datatmp7$Revenu.fiscal.de.référence.par.tranche..en.euros. == "Total") # Sélection des seules variables totales
datatmp7[, c(5:length(datatmp7))]<- lapply(datatmp7[, c(5:length(datatmp7))], as.numeric) # Variables en numériques
# Création d'un CODGEO
datatmp7$CODGEO <- substr(datatmp7$DÉP, 1, 2)
datatmp7$CODGEO <- paste(datatmp7$CODGEO, datatmp7$Commune, sep = "")

# Jointure avec le champ CODGEO 2011 de référence (issu des géométries)
df <- merge(df, datatmp1, by = "CODGEO", all.x  = TRUE)
df <- merge(df, datatmp2[,c(1, 5:length(datatmp2))], by = "CODGEO", all.x  = TRUE)
df <- merge(df, datatmp3[,c(1, 3:length(datatmp3))], by = "CODGEO", all.x  = TRUE)
df <- merge(df, datatmp4, by.x = "CODGEO", by.y = "Code.INSEE", all.x  = TRUE)
df <- merge(df, datatmp5[,c(1, 5:length(datatmp5))], by = "CODGEO", all.x  = TRUE)
df <- merge(df, datatmp6[,c(5, 12)], by.x = "CODGEO", by.y = "cog..code.officiel.géographique.", all.x = TRUE)
df <- merge(df, datatmp7[,c(5:length(datatmp7))], by = "CODGEO", all.x = TRUE)

# Ne conserver que les indicateurs d'intérêt 
selec <- target$INSEE_CODE
df2011 <- df[,selec]

# Renommer le code des variables
colnames(df2011) <- target$recoding

```

Les catégories du zonage en aires urbaines ont également été regroupées, pour faciliter les analyses de cette typologie. Nous avons ainsi créé des catégories pour les communes constituant par exemple les petits pôles (codes ZAU 221 et 222), une catégorie hors influence des pôles (300 et 400) ou encore les communes périurbaines (112 et 120).

```{r zau_categ}
# Pour créer des catégories plus vastes à partir des 
# Utilisation du ZAU pour cibler les communes appartenant à un petit pôle (unité urbaine et couronne)

# Utilisation du ZAU pour cibler les communes constituant les petits pôles
df2011$ZAU_POL [df2011$CATAEU2010 %in% c("221", "222")] <- "OUI"

# Utilisation du ZAU pour cibler les communes du rural profond
df2011$ZAU_RUR [df2011$CATAEU2010 %in% c("300", "400")] <- "OUI"

# Utilisation du ZAU pour cibler les communes du rural profond + couronnes petits pôles : Marges Sans Pôles
df2011$ZAU_MAR_SP [df2011$CATAEU2010 %in% c("222", "300", "400")] <- "OUI"

# Utilisation du ZAU pour cibler les communes du rural profond + petits pôles et couronnes
df2011$ZAU_MAR [df2011$CATAEU2010 %in% c("221", "222", "300", "400")] <- "OUI"

# Utilisation du ZAU pour cibler les communes périurbaines et les autres
df2011$ZAU_PERI [df2011$CATAEU2010 %in% c("112", "120")] <- "OUI"

# Utilisation du ZAU pour cibler les communes des Grandes aires urbaines, des aires urbaines et les autres
df2011$ZAU_AU [df2011$CATAEU2010 %in% c("111", "112", "120")] <- "GrdAirUrb"
df2011$ZAU_AU [df2011$CATAEU2010 %in% c("211", "212", "221", "222")] <- "AirUrb"
df2011$ZAU_AU [df2011$CATAEU2010 %in% c("300", "400")] <- "Autres"

# Tout ce qui ne fait pas partie des catégories = NON 
selecV <- c("ZAU_POL", "ZAU_RUR", "ZAU_MAR_SP", "ZAU_MAR", "ZAU_PERI", "ZAU_AU")
df2011[selecV][is.na(df2011[selecV])] <- "NON"

# # Si on souhaite, transformation en facteur des catégories des aires urbaines
# df2011$CATAEU2010 <- as.factor(df2011$CATAEU2010)
# df2011$CODGEO <- as.character(df2011$CODGEO)

```



## 3.3 - Données concernant les fusions communales et les communes nouvelles
La partie la plus technique de l'importation a concerné les données concernant les fusions communales. Nous avons tout d'abord importé la [table de passage communale](https://www.insee.fr/fr/information/2028028) qui présente l'ensemble des changements qui ont touché des communes en France depuis 2003 ainsi que les tables mises à disposition par l'INSEE ([un fichier par année depuis 2016](https://www.insee.fr/fr/information/2549968)).

Nous avons regroupé toutes ces informations au sein d'un seul objet. Si la date d'effet (Date2) était manquante au niveau des données fournies par l'INSEE, on appliquait alors la valeur au 1^er^ janvier de l'année suivante à ce champ (c'était la signification de l'absence de donnée dans ce champs).  

À noter que pour mettre à jour la table de passage avec d'éventuelles fusions ultérieures, il suffira de rajouter les fichier les plus récents (dans le dossier data-raw comme dans le code pour importer ces derniers) :

* La nouvelle table concernant les fusions de l'année écoulée (2021 par exemple, donc situation au 1^er^ janvier 2022) ;

* La table des évolutions mises à jour (s'appelant probablement 2003-2022).

À noter également que les dates des fichiers Excel fournis par l'INSEE ne sont pas formatés de façon identique. Au format texte jusqu'à 2017, au format date à partir de 2018. Nous avons préalablement converti les champs date au format texte pour l'ensemble des fichiers. Cela signifie qu'en cas de mise à jour des données il faudra de nouveau convertir les dates au format texte (ou, inversement, transformer l'ensemble au format date). 


### 3.3.1 - Identification des communes fusionnantes
Nous avons commencé par identifier les communes ayant connu une fusion à partir de la table de passage globale fournie par l'INSEE depuis la géométrie de 2003. Cette dernière comporte une page dédiée à ces fusions.
Il faut garder à l'esprit que cette table comprend toutes les fusions depuis 2003. Elle comprend donc des fusions de communes qui n'ont pas créé de communes nouvelles. C'est pour cela qu'il ne faudra pas confondre le champs `FUSION` créé ici et le champs `COM_NOUV`, créé plus tard, qui concerne bien les seules communes nouvelles.

```{r changes_manip1}

# comFus <- data.frame(read_excel("data-raw/communes_nouvelles/table_passage_geo2003_geo2020.xlsx", sheet = "Liste des fusions", skip = 5))
comFus <- data.frame(read_excel("data-raw/communes_nouvelles/table_passage_geo2003_geo2021.xlsx", sheet = "Liste des fusions", skip = 5))

# Pour éviter les doublons dans la table INSEE
comFus <- aggregate(x = comFus, by = list(comFus$COM_INI), 
                   FUN = head, 1) # On garde le premier élément (car df trié par date)

# Renommer avec la commune fusionnée la plus récente
comFus <- comFus[order(comFus$annee_modif, decreasing = TRUE),]
comFus$LIB_COM_FIN <- ave(comFus$LIB_COM_FIN, comFus$COM_FIN, FUN = function(x) x[1])
comFus <- comFus[,c(2:length(comFus))]

# Identification des communes fusionnantes dans la table d'entrée
df2011 <- merge(df2011, comFus[,c("COM_INI", "annee_modif")], by.x = "CODGEO",
                by.y = "COM_INI", all.x = TRUE)
df2011$annee_modif[!is.na(df2011$annee_modif)] <- "OUI"
df2011$annee_modif[is.na(df2011$annee_modif)] <- "NON"
colnames(df2011)[length(df2011)] <- "FUSION"


```

### 3.3.2 - Identification et caractérisation des communes nouvelles
Nous avons ensuite importé les informations contenues dans les tables de passage spécifiques (celles fournies année par année depuis 2016 par l'INSEE et celle créée manuellement pour les fusions ayant eu lieu entre 2012 et 2015). Elles concernent bien des communes créées après l'élaboration du statut de commune nouvelle (par la loi du 16 décembre 2010 intitulée « Loi de réforme des collectivités territoriales ») et elles sont plus détaillées concernant ces fusions (création ou non de communes déléguées et date de création sont par exemple renseignés)[^notestatut].

[^notestatut]: Le statut de commune nouvelle a été presque unanimement plébiscité. On peut noter le cas jusqu'ici unique de Fontenoy-le-Château (Vosges), commune nouvelle créée au 1^er^ janvier 2013 mais dont la fusion a été transformée en fusion simple.

Certains cas particuliers ont demandé un traitement spécifique :

* Bettoncourt-le-Haut a fusionné en 1972 avec Épizon, sous le statut de commune-associée. Au 1^er^ janvier 2013, avec la création de la commune-nouvelle d'Épizon, la commune de Bettoncourt-le-Haut est devenue commune déléguée. Comme on ne dispose pas des données 2011 pour Bettoncourt-le-Haut, on préfère ignorer cette dernière en considérant que la commune nouvelle d'Épizon est le résultat de la fusion des seules Épizon et Pautaines-Augeville. Source : [fiche spécifique de l'INSEE](https://www.insee.fr/fr/metadonnees/cog/commune/COM52046-bettoncourt-le-haut).

* On doit également traiter individuellement le cas de la commune de L'Oudon, qui a changé de code communal à plusieurs reprises : issue de la fusion-association de dix communes en 1973, elle avait jusqu'en 1990 le code 14472. Du fait d'un transfert de chef-lieu, le code a été modifié en 14697. Après un nouveau transfert de chef-lieu en  2014,  l'INSEE décide en  2016  de  ré-attribuer  le  code de  14472. Cette commune a ensuite fusionné au 1^er^ janvier 2017 au sein de la commune nouvelle de Saint-Pierre-en-Auge. Pour éviter les problèmes d'associations entre les données, nous avons laissé l'ancien code 14697, qui est celui utilisé dans les données INSEE que nous utilisons (millésime 2011).


Enfin, nous avons choisi de distinguer les vagues de fusions : une première, concernant très peu de communes, entre le 1^er^ janvier 2011 et le 1^er^ janvier 2015 inclus, ensuite une vague par an pour les années 2015, 2016, 2017 et 2018 puis un creux assez net nous a conduit à réunir les années 2019 et 2020. Cette périodisation pourra être modifiée en fonction d'évolutions les prochaines années (la poursuite des fusions est probable).

```{r changes_manip2}

# Import tables de référence INSEE
tmp <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2012_2014.xls", 
                              sheet = "Communes_nouvelles_2012_2014"))
# Traitement du cas particulier de Bettoncourt-le-Haut et Épizon
tmp <- subset (tmp, DepComA != "52046")

tmp1 <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2015.xls", 
                              sheet = "Communes nouvelles 2015"))
tmp1$Date2[is.na(tmp1$Date2)] <- "01/01/2016"

tmp2 <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2016.xls", 
                              sheet = "Communes nouvelles 2016"))
tmp2$Date2[is.na(tmp2$Date2)] <- "01/01/2017"

# Traitement du cas particulier de la commune de L'Oudon
# tmp2$DepComA[tmp2$NomCA == "Oudon (L')"] <- "14697"
tmp2$DepComA[tmp2$DepComA == "14472"] <- "14697"

tmp3 <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2017.xls", 
                              sheet = "Communes nouvelles 2017"))
tmp3$Date2[is.na(tmp3$Date2)] <- "01/01/2018"

tmp4 <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2018.xls", 
                              sheet = "Communes_nouvelles_2018"))
tmp4$Date2[is.na(tmp4$Date2)] <- "01/01/2019"

tmp5 <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2019.xls", 
                              sheet = "Communes_nouvelles_2019"))

tmp6 <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2020.xlsx", 
                              sheet = "Communes_nouvelles_2020"))
tmp6$Date1 <- format(as.Date(tmp6$Date1, format = "%Y-%m-%d"),"%d/%m/%Y") # Pour mettre la date au même format que les fichiers précédents
tmp6$Date2 <- format(as.Date(tmp6$Date2, format = "%Y-%m-%d"),"%d/%m/%Y") # Pour mettre la date au même format que les fichiers précédents

# Regroupement des colonnes identiques des différents dataframe
comNew <- data.frame()
list_df <- list(tmp, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6)

for(item in list_df){     
  items <- item[, names(tmp)] # La référence sont les noms de colonne du premier fichier
  comNew <- rbind(comNew, items)    

}

# Supprimer lignes qui ne concernent que des commentaires dans la feuille excel importée
comNew <- subset(comNew, comNew$DepComN != "NA")
# test <- dplyr::anti_join(comNew, comNew2) # Si on souhaite identifier ces erreurs

# Reformatage de l'année de fusion
comNew$FusAn <- as.Date(comNew$Date2, tryFormats = "%d/%m/%Y")

# Découpage en phases temporelles de fusion
comNew$FusPhas <- cut(comNew$FusAn, 
                        breaks = as.Date(c("2011-1-1", "2015-1-2", "2016-1-2",
                                           "2017-1-2","2018-1-2", "2019-1-2","2021-1-2")), 
                        labels = c("Phase 1", "Phase 2", "Phase 3", "Phase 4", "Phase 5", "Phase 6"))

# Pour fusions successives et à code DepComA identique, ne conserver que l'élément le plus ancien
comNew <- aggregate(x = comNew, by = list(comNew$DepComA),  # on évite les doublons
                   FUN = head, 1) # On ne garde que le premier élément (comNew trié par ordre chronologique)

# Prise en compte du dernier nom de commune nouvelle
comNew <- comNew[order(comNew$FusAn, decreasing = TRUE),]
comNew$NomCN <- ave(comNew$NomCN, comNew$DepComN, FUN = function(x) x[1])
comNew <- comNew[,c(2:length(comNew))] # Ne garder que les colonnes utiles

# Jointure avec le fichier d'origine
df2011 <- merge(df2011, comNew[,c("DepComA","ChefLieu","ComDLG", "FusAn","FusPhas")],
                by.x = "CODGEO", by.y = "DepComA", all.x = TRUE, all.y = TRUE)

# Identification communes nouvelles
df2011$COM_NOUV[!is.na(df2011$FusPhas)] <- "OUI"
df2011$COM_NOUV[is.na(df2011$FusPhas)] <- "NON"
df2011$FusPhas <- as.character(df2011$FusPhas)


# Pour comparer les données issues de la table générale et celles compilées à partir des tables années par années, on peut créer l'objet suivant :
DiffcomFuscomNew <- dplyr::anti_join(comFus, comNew, by = c("COM_INI" = "DepComA")) 

# Les principales différences sont bien liées à la période plus large de la table générale (prend en compte les fusions avant 2011, qui ne sont pas des communes nouvelles)


```

### 3.3.3 - Gestion des scissions communales
Dans la table de passage, des scissions communales étaient mentionnées. L'étape présentée ici a permis que ces dernières ne soient pas considérées comme des fusions ou des communes nouvelles.

Il faut, là encore, noter un cas particulier : en 2012, la commune de Robert-Magny-Laneuville-à-Rémy (52427) se scinde en Robert-Magny (52427) et Laneuville-à-Rémy (52266). Au 1^er^ janvier 2016, Robert-Magny fusionne avec Montier-en-Der (52331) pour former La Porte du Der (52331). Comme on ne dispose pas des données 2011 pour Laneuville-à-Rémy, on préfère ignorer cette scission. Source : [fiche spécifique de l'INSEE](https://www.insee.fr/fr/metadonnees/cog/commune/COM52427-robert-magny).

```{r changes_manip3}

# Tout ce qui est scission n'est pas considéré comme commune nouvelle ou fusion
# comSci <- data.frame(read_excel("data-raw/communes_nouvelles/table_passage_geo2003_geo2020.xlsx", sheet = "Liste des scissions", skip = 5))
comSci <- data.frame(read_excel("data-raw/communes_nouvelles/table_passage_geo2003_geo2021.xlsx", sheet = "Liste des scissions", skip = 5))


# Cas particulier de la commune de Robert-Magny-Laneuville-à-Rémy (52427).
comSci <- subset(comSci, COM_INI != "52427")
comSci <- as.vector(unique(comSci$COM_FIN))

df2011$FUSION [df2011$CODGEO %in% comSci] <- "NON"
df2011$COM_NOUV [df2011$CODGEO %in% comSci] <- "NON"
df2011$ChefLieu [df2011$CODGEO %in% comSci] <- NA
df2011$ComDLG [df2011$CODGEO %in% comSci] <- NA
df2011$FusAn [df2011$CODGEO %in% comSci] <- NA
df2011$FusPhas [df2011$CODGEO %in% comSci] <- NA

df2011$FusAn <- as.character(df2011$FusAn)

```



## 3.4 - Agrégation des indicateurs en version la plus récente et calcul des ratios
Une étape majeure a ensuite été l'agrégation des indicateurs, pour les communes ayant fusionné. Cette agrégation, si elle est parfois simple (pour les statistiques de stocks, il s'agit de banales additions), a été rendue plus ardue par la présence de ratios.
Pour ce faire, une fonction spécifique, `comix`, a été créée. Elle permet d'agréger les données selon leurs spécificités statistiques (données textuelles, de stock, de ratio).


```{r comix, echo = FALSE}

comix <- function(x, xid, app, app.init, app.target, var, var.type, w = NULL, na.rm = FALSE) {
  
  # Supprimer les géométries s'il y en a 
  if (methods::is(x, "sf")){
    x <- st_set_geometry(x, NULL)
    }
  
  # Import table d'appartenance des fusions territoriales
  app <- app
  
  # Jointure table d'entrée - table des fusions territoriales
  x <- merge(x, app[,c(app.init, app.target)], by.x = xid, by.y = app.init, all.x = TRUE)
  

  # Unités non concernées par modifications
  tmp <- aggregate(x[,app.target], by = list(app.target = x[,app.target]), FUN = length)
  tmp <- tmp[tmp$x <= 1,] 
  selecUnit <- tmp$app.target
  intact <- x[x[,app.target] %in% selecUnit, ]
  intact <- intact[, c(app.target, var)] 

  # Unités concernées par une modification
  modif <- x[!x[,app.target]%in% selecUnit, ]
  modif <- modif[, c(app.target, var, w)]
  
  # Gestion des types de variables déclarées 
  tmp <- data.frame(var, var.type, row.names = var)
  txt <- row.names(tmp[tmp$var.type == "text",])
  stock <-  row.names(tmp[tmp$var.type == "stock",])
  ratio <- row.names(tmp[tmp$var.type == "ratio",])
  
  # Si variables de type caractère > concaténation des modalités
  if(length(txt > 0)){
    modif.t <- modif[,c(app.target, txt)]
    
    modif.t <- aggregate(modif.t[, -1],
                         by = list(app.target = modif.t[,app.target]),
                         FUN = function(x) {paste0(unique(x), collapse = "-")})
    names(modif.t) <- c(app.target, txt)
    }

  
  # Si variables de type stock > somme des valeurs
  if(length(stock > 0)){
    
    modif.s <- modif[,c(app.target, stock)]
    modif.s <- aggregate(modif.s[, -1],
                         by = list(app.target = modif.s[,app.target]),
                         FUN = sum, na.rm = na.rm)
    names(modif.s) <- c(app.target, stock)
    }
  

  # Si variables de type ratio > moyenne simple ou pondérée 
  ## Si pas de variable de pondération
  if(length(ratio > 0)){  
    if(is.null(w)){
      modif.r <- modif[,c(app.target, ratio)]
      modif.r <- aggregate(modif.r[, -1],
                           by = list(CODGEO_new = modif.r$CODGEO_new),
                           FUN = mean, na.rm = na.rm)
      }
    
    ## Si pondération... 
    # Commentaire : Avec dplyr(!), pas très sexy mais fonctionne. A essayé 36 méthodes
    # non concluantes (cf sous la fonction)
    else{
      modif.r <- modif[,c(app.target, ratio, w)]
      names(modif.r)[which(names(modif.r) == w)] <- "weight"
      names(modif.r)[which(names(modif.r) == app.target)]  <- "app.target"
      names(modif.r)[which(names(modif.r) %in% ratio)]  <- paste0("ratio",names(modif.r[ratio]))
      
      modif.r <- modif.r %>%                   
        group_by_at(vars(app.target)) %>% 
        summarise_at(vars(starts_with('ratio')), list(~weighted.mean(., weight, na.rm = na.rm)))  
        modif.r <- as.data.frame(modif.r)
        }
    
    names(modif.r) <- c(app.target, ratio)
  }
  
  # Union des 3 types de variables - 8 cas de figure
  # Commentaire : pas trouvé la solution du type if(exists("x")), cbind(x)
  if(exists("modif.t") == FALSE & exists("modif.s") == FALSE & exists("modif.r") == FALSE ){
    stop("Define at least one var combined to one var.type", call. = FALSE)
  }
  
  if(exists("modif.t") == TRUE & exists("modif.s") == TRUE & exists("modif.r") == TRUE ){
    modif <- cbind(modif.t, modif.s, modif.r) 
  }
  
  if(exists("modif.t") == FALSE & exists("modif.s") == TRUE & exists("modif.r") == TRUE ){
    modif <- cbind(modif.s, modif.r) 
  }
  
  if(exists("modif.t") == TRUE & exists("modif.s") == FALSE & exists("modif.r") == TRUE){
    modif <- cbind(modif.t, modif.r) 
  }
  
  if(exists("modif.t") == TRUE & exists("modif.s") == TRUE & exists("modif.r") == FALSE){
    modif <- cbind(modif.t, modif.s) 
  }
  
  if(exists("modif.t") == TRUE & exists("modif.s") == FALSE & exists("modif.r") == FALSE){
    modif <- modif.t
  }
  
  if(exists("modif.t") == FALSE & exists("modif.s") == TRUE & exists("modif.r") == FALSE){
    modif <- modif.s
  }
  
  if(exists("modif.t") == FALSE & exists("modif.s") == FALSE & exists("modif.r") == TRUE){
    modif <- modif.r
  }
  


  # Liaison avec les unités territoriales inchangées
  x <- rbind(intact, modif[,names(intact)])
  
  return(x)
  }
```


Nous avons, au préalable, importé les zonages de référence pour l'année la plus récente (2021 ici), ce qui permet d'avoir les informations les plus à jour possible (cas de quelques communes ayant changé de département avec les fusions). Ce sont ces zonages qui constituent le matériau de base de l'objet `df_new`.

Dans le code est aussi proposé l'import des données du zonage en aires urbaines, zonage qui n'est cependant plus disponible à partir de la géographie administrative au 1^er^ janvier 2021.

```{r data_ref_comnew}
# Import de la table de zonage de l'année la plus récente
# df_new <- data.frame(read_excel("data-raw/stats_insee/table-appartenance-geo-communes-20.xlsx",  sheet = "COM", skip = 5))
df_new <- data.frame(read_excel("data-raw/stats_insee/table-appartenance-geo-communes-21.xlsx",  sheet = "COM", skip = 5))

df_new <- df_new[,c("CODGEO","LIBGEO","DEP","REG")] # NB : certains éléments ne sont plus dans les données à partir de 2021 : "CATAEU2010","AU2010", "EPCI"... Ont donc été supprimées. Il faudra songer à intégrer le nouveau zonage lorsqu'il sera disponible. Ci-dessous, commenté, le code qui servait à l'intégration des données jusqu'en 2020

# df_new <- df_new[,c("CODGEO","LIBGEO","DEP","REG","CATAEU2010","AU2010","EPCI")]
# colnames(df_new)[1:3] <- c("CODGEO_new","LIBGEO_new","CODE_DEPT") 
# # Création catégories
# df_new$ZAU_POL [df_new$CATAEU2010 %in% c("221", "222")] <- "OUI"
# df_new$ZAU_RUR [df_new$CATAEU2010 %in% c("300", "400")] <- "OUI"
# df_new$ZAU_MAR_SP [df_new$CATAEU2010 %in% c("222", "300", "400")] <- "OUI"
# df_new$ZAU_MAR [df_new$CATAEU2010 %in% c("221", "222", "300", "400")] <- "OUI"
# df_new$ZAU_PERI [df_new$CATAEU2010 %in% c("112", "120")] <- "OUI"
# df_new$ZAU_AU [df_new$CATAEU2010 %in% c("111", "112", "120")] <- "GrdAirUrb"
# df_new$ZAU_AU [df_new$CATAEU2010 %in% c("211", "212", "221", "222")] <- "AirUrb"
# df_new$ZAU_AU [df_new$CATAEU2010 %in% c("300", "400")] <- "Autres"
# # Tout ce qui ne fait pas partie des catégories = NON 
# selecV <- c("ZAU_POL", "ZAU_RUR", "ZAU_MAR_SP", "ZAU_MAR", "ZAU_PERI", "ZAU_AU")
# df_new[selecV][is.na(df_new[selecV])] <- "NON"


colnames(df_new)[1:3] <- c("CODGEO_new","LIBGEO_new","CODE_DEPT") 



```


Nous avons ensuite utilisé la fonction `comix` précédemment créée pour agréger les données d'intérêt en fonction de la géographie la plus récente (ici, au 1^er^ janvier 2021).

Les variables agrégées ont ensuite été jointes à la table `df_new`. Les codes INSEE aux géographies du 1^er^ janvier de l'année la plus récente ont également été joints à la table de données du 1^er^ janvier 2011. 

```{r data_aggreg}

# Agrégation des données de 2011 vers l'année la plus récente (stock + texte)
# Import de la table de passage 
# modif <- as.data.frame(read_xlsx("data-raw/communes_nouvelles/table_passage_geo2003_geo2020.xlsx", col_types = "text", sheet = "Table de passage", skip = 5))
modif <- as.data.frame(read_xlsx("data-raw/communes_nouvelles/table_passage_geo2003_geo2021.xlsx", col_types = "text", sheet = "Table de passage", skip = 5))
colnames(modif) <- c("CODGEO_INI", "CODGEO_new", "LIBGEO_new" )

# Agrégation
tmp <- comix(x = df2011, xid = "CODGEO", app = modif,
                app.init = "CODGEO_INI", app.target = "CODGEO_new", 
                var = c("CODGEO", colnames(df2011)[c(8:40)], "FUSION", "FusAn",
                        "FusPhas", "COM_NOUV", "CATAEU2010"),
                var.type = c("text", rep("stock",33), rep("text",5)))

# Gestion des "OUI-NON" > transformé en "OUI"
selec <- c("FUSION", "COM_NOUV")
tmp[,selec][tmp[,selec] == "OUI-NON"] <- "OUI"
tmp[,selec][tmp[,selec] == "NON-OUI"] <- "OUI"

# Jointure avec le fichier de référence le plus récent
df_new <- merge(df_new, tmp, by.x = "CODGEO_new", by.y = "CODGEO_new",
                all.x = TRUE)

# Suppression des territoires corses, des DOM et des communes associées (pas de geom)
out <- c("94","01","02","03","04","06")
df_new <- df_new[!df_new$REG %in% out,] 
df_new <- df_new[!is.na(df_new$CODGEO),]


# Jointure des codes géographiques récents pour df2011
df2011 <- merge(df2011, modif, by.x = "CODGEO", by.y = "CODGEO_INI", all.x = TRUE)

# Gestion des chefs-lieux dans les fusions successives
# Suppression des chefs lieux des communes ayant fusionné a posteriori
df2011$ChefLieu <- ifelse(df2011$CODGEO == df2011$CODGEO_new, "O", "N")

# Transformation en factor d'un champ
#df_new$CATAEU2010 <- as.factor(df_new$CATAEU2010) # Ne sont plus dans les données à partir de 2021
df2011$CATAEU2010 <- as.factor(df2011$CATAEU2010)

```


Pour les jeux de données aux géographies 2011 et pour l'année la plus récente, des ratios d'intérêt ont été compilés à partir des stocks préalablement chargés et agrégés. Ces ratios ont été définis sur les bases de ce qui est renseigné dans la feuille "ratios" du fichier meta.xls.

```{r ratios}

ratio <- as.data.frame(read_excel("data-raw/meta.xlsx", sheet = "ratios"))

# Compilation des ratios pour les communes 2011
for (i in 1:nrow(ratio)){
  df2011[paste0(ratio[i,"CODE"])] <- df2011[[ratio[i, "Numerator_Code"]]] / 
    df2011[[ratio[i, "Denominator_Code"]]] * ratio[i,"Coeff"]
}

# Compilation des ratios pour les communes à la dernière géométrie connue
for (i in 1:nrow(ratio)){
  df_new[paste0(ratio[i,"CODE"])] <- df_new[[ratio[i, "Numerator_Code"]]] / 
    df_new[[ratio[i, "Denominator_Code"]]] * ratio[i,"Coeff"]
}

```


## 3.5 - Résumé des indicateurs disponibles par fichier de données de référence
Deux jeux de données ont ainsi été produits :
* Le premier, `df2011`, contient l'ensemble des données communales françaises désirées en fonction de la géographie administrative au 1^er^ janvier 2011. 
* Le second, `df_new`, contient les informations en fonction de la géographie administrative du 1^er^ janvier de la dernière année pour laquelle les données ont été publiées par l'INSEE. Les données 2011 ont été regroupées en fonction du fichier des fusions délivré par l'INSEE et la fonction `comix`.

Voici les codes respectifs que ces fichiers contiennent, ainsi qu'un descriptif de leur contenu. 

```{r meta_df2011, echo = FALSE}

codes <- names(df2011)
nums <- target$DESCRIPTION

zau <- c("Petit pôle et couronne de petits pôles (catégories 221 et 222 du zonage en aires urbaines (OUI/NON)",
         "Communes rurales et autres (catégories 300 et 400 du zonage en aires urbaines (OUI/NON)",
         "Marges sans pôles (catégories 222, 300 ey 400 du zonage en aires urbaines (OUI/NON)",
         "Rural profond + petits pôles et couronnes (catégories 221, 222, 300 et 400 du zonage en aires urbaines (OUI/NON)",
         "Périurbain de grands pôles (catégories 112 et 120 du zonage en aires urbaines (OUI/NON)",
         "Typologie regroupée basées sur les aires urbaines : GrdAirUrb (catégories 111, 112, 120), AirUrb (211, 212, 221, 222) et Autres (300, 400)")
change <- c("Code INSEE, découpage géographique le plus récent",
            "Nom de la commune, découpage géographique le plus récent",
            "Est-ce que la commune a fusionné entre 2011 et aujourd'hui (OUI/NON)",
            "Commune nouvelle : Statut de commune chef-lieu (O=OUI, N=NON)",
            "Commune nouvelle : Statut de Commune déléguée (O=OUI, N=NON)",
            "Date d'effet de la création de commune nouvelle",
            "Phase dans le processus de fusion (phase 1 = 2011-2015, 2 = 2015-2016, 3 = 2016-2017, 4 = 2017-2018, 5 = 2018-2020, 6 = 2020-2021",
            "Est que la commune est devenue une commune nouvelle (OUI/NON)")

rates <- ratio$DESCRIPTION

label <- c(nums, zau, change, rates)
tab <- data.frame(codes, label)

# knitr::kable(tab, row.names = F) # Pour export html
ft <- flextable(tab)
ft <- width(ft, width = 4)
ft
```

Les mêmes codes ont été utilisés pour `df_new`, à la différence que l'identifiant géographique des communes correspond à CODGEO_new et son libellé LIBGEO_new. Dans `df_new`, CODGEO correspond à la concaténation des communes constituant la commune nouvelle. Les variables dédiées aux chefs-lieux et aux communes déléguées (codes ChefLieu et ComDLG) ne sont pas inclues dans le jeu de données aux géographies récentes, car non adaptées à ce niveau de granularité géographique. 

Les jeux de données de référence ont finalement été exportés dans le dossier `data` au format RData. 

```{r export_data}
# Trois lignes ci-desssous pour créer le dossier nécessaire à l'accueil des données créées
# setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # On définit le dossier en cours comme répertoire de travail
# getwd() # Pour vérification
# dir.create("data") # création du dossier destiné à accueillir les données créées

try(save(df2011, df_new, file = "data/refdata.Rdata"))

```

## 3.6 - Agrégation des dernières géométries connues (2021), extraction des communes nouvelles et export des résultats
Après avoir traité les données, il s'est agit d'agréger les géométries aux géographies du 1^er^ janvier 2011 vers les géométries les plus récentes pour lesquelles des données ont été publiées par l'INSEE (ici, 1^er^ janvier 2021). Des objets ont ensuite été spécifiquement créés pour isoler les communes fusionnantes (`geomfus2011`) et les communes nouvelles (`geomCN_new`).

```{r geom_aggreg}

# Communes françaises au 1er janvier 2011
geom2011 <- geom2011[,c("CODGEO")]

# Communes françaises à la géométrie la plus récente
geom_new <- merge(geom2011, df2011[,c("CODGEO","CODGEO_new")])
geom_new <- aggregate(x = geom_new[,"CODGEO_new"], 
                      by = list(geom_new$CODGEO_new), FUN = head, 1)
geom_new <- geom_new[,c("CODGEO_new")]


# Communes nouvelles avant et après fusion
geomfus2011 <- merge(geom2011, df2011[,c("CODGEO", "COM_NOUV")])
geomCN_new <- merge(geom_new, df_new[,c("CODGEO_new", "COM_NOUV")])

geomfus2011 <- geomfus2011[geomfus2011$COM_NOUV == "OUI",]
geomfus2011 <- geomfus2011[,c("CODGEO")]
geomCN_new <- geomCN_new[geomCN_new$COM_NOUV == "OUI",]
geomCN_new <- geomCN_new[,c("CODGEO_new")]

```

Au final, cinq couches géographiques ont été exportées dans le fichier `geom.gpkg`, exporté dans le dossier "data" :

* Les géométries communales au 1^er^ janvier 2011 (`geom2011`).

* Les géométries communales au 1^er^ janvier de l'année la plus récente pour laquelle des données ont été publiées par l'INSEE (2021) (`geom_new`).

* Les géométries des communes concernées par une création de communes nouvelles, avant fusion (`geomfus2011`).

* Les géométries des communes nouvelles, après fusion (`geomCN_new`).

* Une couche d'habillage pour les représentations cartographiques : les départements (`dep`).


```{r geom_export}
# Export des fichiers consolidés
st_write(obj = geom2011, dsn = "data/geom.gpkg", layer = "geom2011", delete_layer = TRUE, quiet = TRUE)
st_write(obj = geom_new, dsn = "data/geom.gpkg", layer = "geom_new", delete_layer = TRUE, quiet = TRUE)
st_write(obj = geomfus2011, dsn = "data/geom.gpkg", layer = "geomfus2011", delete_layer = TRUE, quiet = TRUE)
st_write(obj = geomCN_new, dsn = "data/geom.gpkg", layer = "geomCN_new", delete_layer = TRUE, quiet = TRUE)
st_write(obj = dep, dsn = "data/geom.gpkg", layer = "dep", 
         delete_layer = TRUE, quiet = TRUE)
```



# 4 - Traitements possibles
Nous proposons ici quelques exemples de traitements rendus possibles par la base de donnée ainsi constituée.

## 4.1 - La création des communes nouvelles au cours du temps
Il est par exemple possible d'avoir une vision chronologique des créations de communes nouvelles ou, pour être plus précis, du nombre de communes fusionnantes ayant rejoint une commune nouvelle pour une année donnée (on a plusieurs cas de fusions successives). C'est ce que propose ce graphique en montrant le nombre de communes fusionnantes en fonction de l'année de la fusion (dans ce graphique, comme dans les tables de l'INSEE, les fusions effectives au 1^er^ janvier d'une année *n* sont notées à l'année *n-1*). On y observe bien les différentes périodes qui nous ont conduit à identifier six phases (cf. plus haut).

```{r traitement_graph_annee}

datafus2011 <- subset(df2011, COM_NOUV == "OUI") # Désigne les données concernant les communes ayant participé à la création d'une commune nouvelle, appelées ici communes fusionnantes

datafus2011$FusAn <- as.Date(datafus2011$FusAn, tryFormats = "%Y-%m-%d")

datafus2011$FusAnnee <- cut(datafus2011$FusAn, 
                        breaks = as.Date(c("2011-1-1", "2012-1-2", "2013-1-2", "2014-1-2", "2015-1-2", "2016-1-2",
                                           "2017-1-2","2018-1-2", "2019-1-2", "2020-1-2", "2021-1-2")), 
                        labels = c("2011", "2012", "2013", "2014", "2015", "2016", "2017", "2018", "2019", "2020")) # NB : On intègre le 1er janvier d'une année n à l'année précédente

time_serie <- data.frame(table(datafus2011$FusAnnee))

barplot(time_serie$Freq,  xlab = " ", ylab = "Nombre de communes fusionnantes", main = "Nombre de communes fusionnantes\nen fonction de l'année de fusion", ylim = c(0, 2000), names.arg = time_serie$Var1)
grid(nx=0, ny = 10, col="gray", lwd=2)

```

Cette répartition peut ensuite être cartographiée, nous utilisons justement ici les phases en question.


```{r traitement_carte_comm_annee}

geomfus2011 <- merge(geomfus2011, datafus2011, by = "CODGEO") # jointure données/géométries

col <- c("#a50026","#d73027","#f46d43","#fdae61","#fee090", "#ffffbf") # Échelle rouge vers le plus clair
plot(st_geometry(dep), border = "#1A1A19", col = "white", lwd = 1)
typoLayer(x = geomfus2011, var = "FusPhas",  
          col=col,
          border = NA, 
          legend.title.cex = 0.7,
          legend.values.cex = 0.6,
          legend.title.txt = " ",
          legend.pos = "left", 
          legend.values.order = c("Phase 1", "Phase 2", "Phase 3", "Phase 4", "Phase 5", "Phase 6"),
          add = T)

layoutLayer(title = "Communes fusionnantes (2012-2021) par phases",
            author = "Auteur anonymisé",
            tabtitle = TRUE, frame = FALSE, col = "white", coltitle = "black",
            sources = "Sources : INSEE, IGN, 2021")

```



## 4.2 - Communes fusionnantes et zonage en aire urbaine
À partir des données INSEE précisant le zonage en aire urbaine de chaque commune (CATAEU2010), nous pouvons observer le profil des communes fusionnantes en le comparant à celui des communes inchangées.


```{r traitement_graph_ZAU}
dataNfus2011 <- subset(df2011, COM_NOUV == "NON") # Les communes, à la géométrie 2011, qui n'ont pas participé à la création d'une commune nouvelle

ZAU_non <- data.frame(dataNfus2011$CATAEU2010)
ZAU_oui <- data.frame(datafus2011$CATAEU2010)

ZAU_non$Fusion <- "Communes inchangées"
ZAU_oui$Fusion <- "Communes fusionnantes"

colnames(ZAU_non)[1] <- "CATAEU2010"
colnames(ZAU_oui)[1] <- "CATAEU2010"

ZAU <- rbind(ZAU_oui, ZAU_non)

ZAU <- table(ZAU$Fusion, ZAU$CATAEU2010)

prop <- prop.table(ZAU, 1) * 100

barplot(prop, main= NULL,
        xlab = "Catégories d'aire urbaine",
        ylab = "Part du total des communes (%)",
        las = 2,
        border = NA,
        col=c("#ff87a9","#f7d358"),
        beside = TRUE)

legend(x="topright", legend = rownames(prop) , cex=0.8,
       fill=c("#ff87a9","#f7d358"),bty="n")     

tab.chi2 <- chisq.test(ZAU)
```

Ces éléments permettent de se rendre compte que les profils des communes fusionnantes et des communes inchangées sont relativement proches. Les écarts les plus importants se situent aux extrêmes : ainsi, les communes fusionnantes sont marquées par une plus faible représentation des communes centres de grands ou moyens pôles dans les communes nouvelles et une sur-représentation des communes multipolarisées ou hors influence des pôles. Il est alors aisé de réaliser des tests de Chi² permettant de rejeter l’hypothèse d’indépendance des deux variables (X² = `r tab.chi2$statistic`, df = `r tab.chi2$parameter` et p-value = `r tab.chi2$p.value`).


De multiples autres traitements sont évidemment rendus possible par la base de données réalisée, comme par exemple l'élaboration d'une typologie à l'aide d'une Classification par Ascendance Hiérarchique (CAH), qui a été réalisée pour les communes créées entre 2012 et le 1^er^ janvier 2020 ([Référence anonymisée]).

## 4.3 - La répartition des communes fusionnantes par départements
À partir de ces données, il est également possible d'observer la répartition des communes fusionnantes en fonction de la trame départementale, en comparant cette répartition avec des données concernant la taille des communes.

Après avoir calculé des variables concernant la taille des communes dans chaque département, on peut ainsi cartographier la répartition des communes ayant participé à la création d'une commune nouvelle vis-à-vis de la répartition des communes de moins de 1000 habitants. Cela permet d'observer que ces deux phénomènes sont en fait rarement pleinement liés : les départements de forts taux de communes de moins de 1000 habitants ne sont ainsi pas forcément ceux où des communes ont fusionné en grand nombre.


```{r Variables_departements, eval = TRUE, echo = FALSE}

dataCN_new <- subset(df_new, COM_NOUV == "OUI") # Les  communes nouvelles, avec les géométries au 1er janvier 2021 et caractérisées par les données à la géométrie 2011 agrégées.

# Nombre de fusions par département
FusionsDep<-data.frame(table(dataCN_new$CODE_DEPT))
colnames(FusionsDep)<-c("CODE_DEPT", "NbrFusions")
depart <- data.frame(table(df2011$CODE_DEPT))
colnames(depart)<-c("CODE_DEPT", "NbrCom2011")
FusionsDep<-merge(FusionsDep, depart, by = "CODE_DEPT", all.y = TRUE) # Fusion avec une table comprenant tous les départements
FusionsDep$NbrFusions[is.na(FusionsDep$NbrFusions)] <- 0


# Nombre de communes fusionnées par département ?
NbrComFusDep <- data.frame(table(datafus2011$CODE_DEPT))
colnames(NbrComFusDep)<-c("CODE_DEPT", "NbrComFus")

FusionsDep <- merge(FusionsDep, NbrComFusDep, by = "CODE_DEPT", all = TRUE)


# Calcul nombre de communes dans chaque département en 2011 (Av) et en 2021 (Ap)
temp<-data.frame(table(df_new$CODE_DEPT))
colnames(temp)<-c("CODE_DEPT", "NbrComAp")
FusionsDep<-merge(FusionsDep, temp, by = "CODE_DEPT") # Fusion avec la table complète sur les départements

temp<-data.frame(table(df2011$CODE_DEPT))
colnames(temp)<-c("CODE_DEPT", "NbrComAv")
FusionsDep<-merge(FusionsDep, temp, by = "CODE_DEPT") # Fusion avec la table complète sur les départements


# Création de statistiques, ici nombre de communes par rapport à des seuils choisis
# Ici communes sous le seuil de 1000 habitants

listeSeuils <- c(50, 100, 200, 500, 1000)

results <- FusionsDep[, c("CODE_DEPT", "NbrComAv", "NbrComAp")]

for (i in listeSeuils) {
temp <- subset(df2011, df2011$P09_POP < i)
temp<-data.frame(table(temp$CODE_DEPT))
colnames(temp)<-c("CODE_DEPT", paste0("ComMoins", i, "habAv"))

temp2 <- subset(df_new, df_new$P09_POP < i)
temp2<-data.frame(table(temp2$CODE_DEPT))
colnames(temp2)<-c("CODE_DEPT", paste0("ComMoins", i, "habAp"))

results <- merge(results, temp, by = "CODE_DEPT", all.x = TRUE)
results <- merge(results, temp2, by = "CODE_DEPT", all.x = TRUE)

results[, paste0("PartComMoins", i, "habAv")] = round((results[, paste0("ComMoins", i, "habAv")] /
                                                        results$NbrComAv *100), 1)
results[, paste0("PartComMoins", i, "habAp")] = round((results[, paste0("ComMoins", i, "habAp")] /
                                                        results$NbrComAp *100), 1)

results[, paste0("EvolNbrComMoins", i, "hab")] = results[, paste0("ComMoins", i, "habAp")] -
  results[, paste0("ComMoins", i, "habAv")] # Calcul de l'évolution en valeur absolue

results[, paste0("EvolComMoins", i, "hab")] =
  round((
  (results[, paste0("ComMoins", i, "habAp")] - results[, paste0("ComMoins", i, "habAv")]) /
    results[, paste0("ComMoins", i, "habAv")] *100), 1) # Calcul du pourcentage d'évolutions du nombre de communes sous le seuil i

results[, paste0("EvolPartComMoins", i, "hab")] =
  round((
  (results[, paste0("PartComMoins", i, "habAp")] - results[, paste0("PartComMoins", i, "habAv")]) / results[, paste0("PartComMoins", i, "habAv")]*100), 1) # calcul de l'évolution de la part des communes sous le seuil i

# Pour calculer le nombre de communes sous le seuil i ayant fusionné
temp3 <- subset(df2011, df2011$P09_POP < i & FUSION == "OUI")
temp3 <- data.frame(table(temp3$CODE_DEPT))
colnames(temp3)<-c("CODE_DEPT", paste0("ComFusMoins", i, "hab"))
results <- merge(results, temp3, by = "CODE_DEPT", all.x = TRUE)

rm(temp, temp2, temp3)
}


FusionsDep <- merge(FusionsDep, results[, c(1, 4:length(results))], by = "CODE_DEPT", all.x = TRUE)
FusionsDep[is.na(FusionsDep)] <- 0 
```

```{r traitement_carte_petitescomm, eval = FALSE}

ShpDep <- as(dep, "Spatial")

svg("figures/Communes nouvelles et petites communes (2012-2021).svg")
# Carte départementale sur communes de moins de 1000 habitants et nombre de fusions

# Carte choroplèthe en fonction du pourcentage de communes de moins de 1000 habitants
choroLayer(spdf = ShpDep, # SpatialPolygonsDataFrame
           df = FusionsDep, # data frame
           spdfid = "CODE_DEPT",
           dfid = "CODE_DEPT",
           var = "PartComMoins1000habAv",
           # Si on souhaite faire les groupes manuellement :
           # breaks = c(0,0.27,5,10, 37), # liste des seuils (hypothèses)
           # col = carto.pal(pal1 = "turquoise.pal", n1 = 6, pal2 = "blue.pal", n2 = 0),
           # Si on souhaite avoir des groupes par quantiles :
           col = carto.pal(pal1 = "red.pal", n1 = 4), method = "quantile",
           nclass = 4,
           add=FALSE,
           legend.pos = "topleft", 
           legend.title.txt = "Pourcentage de communes\nde moins de 1000 habitants")
# On rajoute les cercles en fonction du nombre de communes de moins de 1000 habitants
propSymbolsLayer(spdf = ShpDep, # Ou à la place on peut utiliser "spdf = Communesfus" créé plus haut
                 df = FusionsDep,
                 spdfid = "CODE_DEPT",
                 dfid = "CODE_DEPT",
                 var = "ComMoins1000habAv",
                 inches = 0.2, fixmax = max(FusionsDep$ComMoins1000habAv),
                 #breakval = 3, # On précise une valeur tournant
                 symbols = "circle", 
                 col = "grey",
                 #col2 = "red",
                 legend.pos = "bottomleft",
                 #legend.pos = "right"
                 #legend.title.txt = "\n\n\n\n\nNombre de\ncommunes\nde moins de\n1000 habitants",
                 legend.title.txt = "Communes\nde moins de\n1000 habitants",
                 legend.style = "c",
                 legend.frame = FALSE,
                 add = TRUE)
# On rajoute les cercles en fonction du nombre de communes ayant fusionné
propSymbolsLayer(spdf = ShpDep, # Ou à la place on peut utiliser "spdf = Communesfus" créé plus haut
                 df = FusionsDep,
                 spdfid = "CODE_DEPT",
                 dfid = "CODE_DEPT",
                 var = "NbrComFus",
                 inches = 0.2, fixmax = max(FusionsDep$ComMoins1000habAv),
                 #breakval = 3, # On précise une valeur tournant
                 symbols = "circle",
                 col = "blue",
                 #col2 = "red",
                 legend.pos = "left",
                # legend.title.txt = "\n\nNombre de\ncommunes\nayant participé à la\ncréation d'une\ncommune nouvelle",
                 legend.title.txt = "\nCommunes\nfusionnantes",
                 legend.style = "c",
                 legend.frame = FALSE,
                 add = TRUE)
layoutLayer(title = "Communes nouvelles et petites communes par départements (2012-2021)", coltitle = "black",
            sources = "                                 Source : INSEE, IGN, 2021", scale = NULL,
            author = "                                  Auteur : Auteur anonymisé", frame ="", col = NA, postitle = "center")
dev.off()

```

![**Communes nouvelles et petites communes (2012-2021)**](figures/Communes nouvelles et petites communes (2012-2021).svg)


# Conclusion
La base de donnée dont nous venons de présenter la réalisation permet donc une analyse approfondie du phénomène des communes nouvelles. Qu'il s'agisse de décrire les entités y ayant participé (les communes fusionnantes), les nouvelles entités créées (les communes nouvelles) ou les transformations qu'impliquent la fusion, de nombreuses études sont possibles.

Au-delà de la question des communes nouvelles, les regroupements d'entités géographiques se retrouvent à de multiples échelles. L'analyse de ces derniers pourra, on l'espère, être facilitée par la reproduction de tout ou partie de la démarche que nous venons de détailler. *A posteriori* ou *a priori*, les décisions politiques gagneront toujours à une évaluation ouverte et transparente de leurs conséquences.


# Bibliographie

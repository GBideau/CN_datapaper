---
title: "Data paper : Les communes nouvelles françaises (2012-2022) : une méthode pour l'analyse de données à l'échelon municipal selon des limites évolutives / Municipal merger in France (2012-2022): a methodology for data analysis at municipal level with moving boundaries"
author: "G. Bideau et R. Ysebaert"
date: '`r format(Sys.Date(), "%d %B %Y")`'
output:
     # html_document:
     # toc: true
     # theme: united
    word_document:
         reference_docx: css/stylesCybergeo.docx # Si export en word
bibliography: biblio/Datapaper.bib
csl: https://journals.openedition.org/cybergeo/32003?file=1 # ou biblio/cybergeo14032018.csl

# editor_options: 
#   chunk_output_type: console
#nocite: '@*' # permet que toutes les références de la bibliographie soient citées, même sans appel dans le texte

# NB : À modifier manuellement dans le fichier .docx : 
# - Enlever date
# - Remplacer \`A para\^itre par À paraître
# - Enlever les .X
# - Modifier les tableaux : noms et largeur de colonne
# - Rajouter les liens hypertextes dans les références bibliographiques
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, # Afficher ou non le code R dans le document
                      eval	= TRUE, #	Exécuter ou non le code R à la compilation
                      include	= TRUE, #	Inclure ou non le code R et ses résultats dans le document
                      # results	“hide”/“asis”/“markup”/“hold”	Type de résultats renvoyés par le bloc de code
                      warning = FALSE, # Afficher ou non les avertissements générés par le bloc
                      message = FALSE, # Afficher ou non les messages générés par le bloc
                      cache = TRUE) # Utiliser le cache pour accélerer les knits.

# Librairies utiles
library(sf)
library(cartography)
library(mapsf)
library(readxl) # Pour import .xls
library(foreign) # Pour import .dbf
library(dplyr) # Pour l'agrégation des données
library(flextable) # Pour la création de tableaux

```


# Résumé
Ce *data paper* détaille la réalisation d'une base de données permettant de décrire le phénomène des créations des "communes nouvelles", entre 2012 et 2022, en France. La création de ces nouvelles entités territoriales, par fusions de plusieurs communes, pose des problèmes d'appariement et de potentiels manques de données. À partir de données issues de la statistique publique (INSEE – Institut National de la Statistique et des Études Économiques – et IGN – Institut Géographique National), il s'agit de proposer un processus de compilation et d'agrégation des données pour les communes ayant fusionné. La méthode est ici détaillée, permettant entre autres sa reproductibilité. 

# Abstract
This data paper presents the creation of a database to describe the phenomenon of the creation of "new municipalities", between 2012 and 2022, in France. These new territorial entities, by merging several municipalities, involve difficulties for merging data and create potentiel missing data. Using data from official statistics (INSEE - National Institute for Statistics and Economic Studies - and IGN - National Geographic Institute), this paper describes a process of compilation and aggregation of data. The method is detailed here, to allow its reproducibility.

# Mots-clés
Géographie administrative, gouvernements locaux, fusions de communes, communes nouvelles, France.

# Keyword
Administrative geography, local governments, municipal mergers, new communes, France.


# Introduction

Depuis 2012, un mouvement sans précédent de constitution de “communes nouvelles” se déploie. Ces regroupements représentent 3,4% de la population française ; entre 2012 et le 1er janvier 2022, 2517 communes (soit 7% des communes françaises) ont contribué à la création de 778 communes nouvelles [@bideau2019]. En effet, le maillage territorial français, parfois qualifié de « mille-feuille », a fait l'objet de nombreuses études et critiques, visant en particulier une hypothétique spécificité bien déconstruite depuis [@grison2016]. L'un des échelons ayant sans doute fait le plus couler d'encre est l'échelle communale, présenté comme le territoire d'identification d'une partie des citoyens mais également comme un résidu de la trame paroissiale d'ancien régime, peu réformée depuis et aujourd'hui inadaptée à l'administration territoriale du fait du trop grand nombre d'entités [@ozouf-marignier2013]. Cela a conduit l'État à mener des politiques de réduction du nombre de communes, comme dans les années 1970 avec les fusions dites « Marcellin » [@lenfant2018 ; @tellier2017]. Aux alentours des années 2010, dans un contexte de transformation de l'organisation territoriale française (lois MAPTAM et NOTRe particulièrement [@2014 ; @2015]) plusieurs parlementaires et élus locaux veulent faciliter les fusions de communes en créant un statut plus attractif pour l'entité nouvellement créée. Il s'agira du statut de « Commune nouvelle », créé par la loi du 16 décembre 2010, plus précisément les articles 21 à 25 du chapitre III au sein du Titre II « Adaptation des structures à la diversité des territoires » [@2010], modifié ensuite [@2019]. Les premières fusions n'auront cependant pas lieu avant 2012, ce qui guidera le choix des données intégrées à la base que nous présentons. Des incitations fiscales seront ensuite votées pour tenter d'accélerer un mouvement d'abord timide [@bideau2019 ; @bideau2020].

La commune nouvelle est un statut qui conduit à ce que plusieurs communes (appelées historiques ou fusionnantes) se regroupent pour ne former qu'une seule entité administrative (par exemple en terme de personnalité juridique ou de budgets). Une subdivision peut être maintenue à l'intérieur de la commune nouvelle : il s'agit des « commune déléguées ». Cependant, ces dernières n'ont qu'un rôle assez limité pour ne pas dire symbolique (existence d'un conseil de la commune déléguée mais uniquement consultatif, un maire déléguée avec des pouvoirs très restreints, possibilité de mentionner le nom de la commune déléguée dans l'état-civil etc).

Si les dimensions juridiques [@aubelle2016 ; @lenfant2018 ; @verpeaux2016] ou politiques [@frinault2017 ; @kada2017; @pasquier2017 ; @ville2017] ont été développées dans les travaux récents, la création de ces nouveaux périmètres de collectivités locales pose un certain nombre de problèmes lorsqu’il s’agit de traiter des données statistiques faisant référence aux communes. Il faut en effet procéder à des appariements de données sur des périmètres variables dans le temps, et donc la création de tables de passage. Une analyse plus fine et quantitative du phénomène des communes nouvelles [@bideauAparaitre] a donc nécessité la création d'une base de données spécifique, qui est l'objet de cette contribution.

Les données fournies par l'INSEE (Institut National de la Statistique et des Études Économiques) sont facilement exploitables pour étudier une situation à une année donnée mais rendent malaisée l'étude des regroupements. La base de données qui est présentée dans cet article, ainsi que le code qui y est associé ont pour objectif de permettre un travail d’analyse du phénomène de fusions en communes nouvelles.

Certains outils existent pour gérer l'évolution des codes géographiques officiels (code communal). Le plus pertinent est sans doute le package `COGugaison`, construit pour le langage R [@antunez2017]. Ce dernier propose plusieurs fonctionnalités : tout d'abord, il permet d'identifier le millésime du code officiel géographique utilisé dans une base de donnée et ensuite il propose quelques outils de visualisation des données au cours du temps[^COGugaison]. L'originalité de la démarche que nous proposons est de fournir une méthode d'agrégation des données, quel que soit le type de ces dernières. En détaillant les changements liés à l'évolution des codes géographiques, nous avons pour but de permettre l’analyse des territoires ainsi construits par les fusions communales.

[^COGugaison]: Pour une présentation plus complète du package, cf. https://antuki.github.io/COGugaison/articles/COGugaison.html ainsi qu'un partenariat récent avec l'Observatoire des Territoires https://www.observatoire-des-territoires.gouv.fr/kiosque/2021-article-un-diagnostic-de-cog-en-deux-clics. Précisons également que le package a été publié à partir de 2017, c'est-à-dire après le début de nos travaux sur les communes nouvelles et la réalisation de notre base de données, raison pour laquelle nous ne l'avons pas forcément utilisé dans notre démarche.

Nous avons donc élaboré, à partir des données issues de la statistique publique, une base permettant l'analyse des communes nouvelles. Nous verrons que sa construction s'inscrit dans une démarche heuristique, dans le but de mieux appréhender l'objet d'étude que sont les communes nouvelles. Il a fallu, pour cela, non seulement gérer l'identification des entités territoriales à différentes dates mais aussi agréger les données de manière *ad hoc* et cohérente avec l'objet institutionnel ainsi remodelé. Les procédures utilisées pourront aisément être reproduites sur d'autres cas de fusions. En effet, la reconfiguration des territoires est un phénomène qui se retrouve à de multiples échelles, et bien plus largement que dans le cas français [@comiteeuropeensurlademocratielocaleetregionalecdlr2007 ; @vanier2002]. Les évolutions de la carte régionale suite à la loi NOTRe de 2015 ont par exemple déjà été étudiées [@dore2021 ; @dumont2018] mais les possibilités d'analyses sont loin d'être épuisées dans le cadre municipal [@bideauAparaitre].

Nous présenterons tout d'abord les objectifs généraux de la réalisation de cette base de données en posant les termes du problème de l’appariement, puis les données disponibles, avant de détailler les méthodes mises en œuvre et d'esquisser quelques applications possibles. Le data paper, la base de données et le code commenté sont diffusés de manière à permettre la reproductibilité de la démarche [^texte].

[^texte]:Une version du texte de ce *data paper*, est publiée au format RMarkdown (.Rmd) avec le dépôt de données, de manière à documenter le code nécessaire à la reproduction de la démarche. Nous tenons à remercier chaleureusement tous ceux qui ont participé à l'élaboration de ce data paper et en particulier Renaud Le Goix ainsi que les membres du comité de lecture de *Cybergéo* pour la qualité de leurs remarques et suggestions.

# 1 - Objectifs généraux

Les communes françaises sont identifiées par l'INSEE via un code communal construit comme unique (variable `CODGEO`), dont l'usage est bien connu. Constitué de cinq chiffres dont les deux premiers (ou trois pour l'outre-mer) reprennent le numéro du département concerné. À un instant *t*, chaque CODGEO ne fait référence qu'à une seule commune, c'est de ce point de vue un identifiant unique.

Ce caractère unique du code communal n'est cependant pas complètement stable dans le temps : outre quelques très rares cas de changements de CODGEO [^Oudon], lors des fusions, l'INSEE a choisi de donner à la nouvelle entité le code de la commune qui en devient le chef-lieu. Ce procédé, qui permet de ne pas avoir à recréer de nouveaux CODGEO pose un problème épineux si on fusionne des données de différentes années puisque l'appariement des séries statistiques peut être erroné, en raison des changements de périmètres, si on ne vérifie pas conjointement le millésime des données et le millésime des limites des communes.

[^Oudon]: L'exemple le plus typique est le cas de la commune de l'Oudon, qui a changé plusieurs fois de code officiel.

À partir des données INSEE et le fond géographique de référence aux géographies du 1^er^ janvier 2011 (avant toute création de commune nouvelle), il s'agit de structurer la base de données pour qu'elle comporte :

* Les géométries de référence au 1^er^ janvier 2011 et au 1^er^ janvier de l'année la plus récente pour laquelle des données ont été publiées par l'INSEE avec le même niveau de généralisation cartographique. Ces objets sont appelés respectivement `geom2011` et  `geom_new`.

* Les géométries des communes qu'on nommera fusionnantes[^fusionnantes], soit avant les fusions, au 1^er^ janvier 2011 (`geomfus2011`) et après les fusions, à la date la plus récente connue (`geomCN_new`).

* Des données statistiques contextuelles pour l'ensemble des communes existant en 2011, regroupées dans l'objet `df2011`. Ces données couvrent des caractéristiques socio-économiques (emploi, structure par âge, etc.), relatives à des zonages (EPCI d'appartenance, catégories d'aires urbaines), et en particulier permettent de caractériser les fusions communales à l’œuvre (quelles communes, laquelle devient chef-lieu, y a-t-il création de communes déléguées, à quelle date etc).

* Ces mêmes données statistiques (donc les plus récentes qui aient été publiées à la géographie administrative de 2011, avant la création de toute commune nouvelle), sont agrégées en fonction de leur nature (stock, ratio, valeurs textuelles) pour constituer l'objet `df_new`, qui reprend la géographie administrative la plus récente (ici 2021).

[^fusionnantes]: Nous désignons ainsi les communes ayant participé à la fusion, c'est-à-dire les communes historiques ; le terme de « commune nouvelle », inscrit dans la loi, désigne la nouvelle entité, après la fusion.

La jointure entre les données et les géométries de référence est évidemment facilitée pour permettre cartographie et analyse spatiale.

![**Figure 1 : Schéma général de la construction de la base de données**](figures/Schema_BdD.png)

Il est à noter que le phénomène des communes nouvelles n'a, du moins pour l'instant, pas du tout touché les communes d'outre-mer ni celles de Corse. Par conséquent, du fait des spécificités territoriales et administratives de ces espaces, nous avons choisi de nous concentrer sur les seules communes de l'« Hexagone », Corse exclue.

# 2 - Présentation des sources
Les sources utilisées pour la construction de données décrivant les communes fusionnées proviennent d’une part de  l'IGN (Institut Géographique National) pour les géométries de référence nécessaires (2.1) et l'INSEE pour les données statistiques (2.2) ainsi que celles permettant de documenter les fusions de communes (2.3). Ces sources sont librement accessibles et permettent de redistribuer des données sources bien documentées selon des protocoles ouverts compatibles avec les exigences de reproductibilité.


## 2.1 - Les géométries de référence
L'IGN propose des données multiples, dont un fond géographique à l'échelle des communes. Nous avons utilisé le fond [Geofla®Communes édition 2011 (France Métropolitaine)](https://geoservices.ign.fr/documentation/diffusion/telechargement-donnees-libres.html#geofla) puisque l'année 2011 est la dernière avant toute création de commune.


## 2.2 - Les données contextuelles statistiques : Fichiers sources et indicateurs cibles
Afin de caractériser les spécificités des communes nouvelles, plusieurs tables statistiques à l'échelon communal sont disponibles. Nous souhaitions pouvoir étudier l'ensemble des communes nouvelles, ce qui impliquait de prendre comme point de départ la géographie administrative au 1^er^ janvier 2011. Or, lorsque l'INSEE publie des données, le millésime annoncé est souvent différent de la géographie administrative utilisée (ces éléments sont alors documentés dans les métadonnées). Ainsi, les tables que nous avons utilisées correspondent généralement au millésime 2009 pour la géographie administrative au 1^er^ janvier 2011.

Le tableau suivant résume les indicateurs ciblés pour la collecte de données. Variables de stocks, ils constituent des numérateurs et dénominateurs qui seront, par la suite, composés en ratios. 

Ces données sont accessibles sur les sites des institutions concernées à partir des noms des jeux de données présents dans la table ci-dessous (les chemins sont précisés dans les métadonnées, *cf.* fichier meta.xlsx).    

```{r stat_target, echo = FALSE}

variables <- as.data.frame(read_excel("data-raw/meta.xlsx", sheet = "ind_target"))
# Pour sélectionner de nouvelles variables, cocher avec "X" dans le fichier meta.xlsx
target <- subset(variables, variable_selec == "X")


# knitr::kable(target[,c("INSEE_CODE","DESCRIPTION", "SOURCE", "PRODUCTEUR")], row.names = F, digits = 1) # Pour export html
ft <- flextable(target[,c("INSEE_CODE","DESCRIPTION", "SOURCE", "PRODUCTEUR")])
ft <- set_caption(ft, caption = "Tableau 1 : Les indicateurs d'intérêt sélectionnés")
ft <- width(ft, width = 1.7)
ft
```

## 2.3 - Données concernant les fusions communales et les communes nouvelles
La [table de passage communale](https://www.insee.fr/fr/information/2028028) produite par l'INSEE restitue l'ensemble des changements qui ont affecté des communes en France depuis 2003. Cette table ne concerne pas exclusivement les communes nouvelles.

Pour cette raison, nous avons associé à ce fichier d'origine d'autres tables mises à disposition par l'INSEE : la liste des communes nouvelles ([un fichier par année depuis 2016](https://www.insee.fr/fr/information/2549968)). Ces dernières comportent, pour chaque commune ayant participé à une fusion, les informations avant et après ce changement, ainsi que la date de décision et d'effet[^tablepassage]. Pour retracer les créations de communes nouvelles antérieures au 2 janvier 2015, un fichier a été créé à partir de l'interface d'[historique des communes](https://www.insee.fr/fr/metadonnees/historique-commune?taille=100&debut=0&modification=MG&p-debut=2003&p-fin=2014) de l'INSEE.

[^tablepassage]: Les tables de passages de l'INSEE comprennent les fusions du 2 janvier de l'année indiquée jusqu'au 1^er^ janvier de l'année suivante, inclus. Par exemple, la première table de passage, publiée en 2016 et appelée table de passage "2015" comprend toutes les fusions du 2 janvier 2015 au 1^er^ janvier 2016.

Le tableau suivant présente le récapitulatif des informations mises à disposition par l'INSEE : 

```{r changes, echo = FALSE}

tab <- as.data.frame(read_excel("data-raw/meta.xlsx", sheet = "tab_passage"))

# knitr::kable(tab, row.names = F) # Pour export html
ft <- flextable(tab[, c("INSEE_CODE", "DESCRIPTION", "SOURCE")])
ft <- set_caption(ft, caption = "Tableau 2 : Les données à disposition concernant les fusions")
ft <- width(ft, width = 1.7)
ft
```



# 3 - Méthodes
Cette section détaille les étapes nécessaires pour importer, préparer et agréger les données relatives à l’analyse du phénomène des communes nouvelles.

## 3.1 - Géométries de référence
La construction des géométries de référence repose sur le fichier géographique [Geofla®Communes édition 2011 France Métropolitaine](https://geoservices.ign.fr/telechargement#geofla) (objet `geom2011`). Comme cela a été dit, cela limite donc la base aux communes dites métropolitaines, en particulier car le phénomène des communes nouvelles n'a jusqu'à présent pas touché les communes ultra-marines. Les communes de Corse ont été également supprimées, étant donné (1) qu'elles ne sont pas concernées par le processus de création de communes nouvelles et (2) que cela permet d'améliorer la résolution et simplicité des représentations cartographiques. 

Les arrondissements marseillais, lyonnais et parisiens ont été agrégés au niveau communal pour un meilleur appariement avec les données statistiques de référence utilisées ultérieurement. Ce fond communal est également agrégé au niveau départemental à des fins de représentation cartographique (`dep`).

Le code communal servant de référence pour les jointures ultérieures avec les données attributaires est extrait de ces géométries.

```{r geom2011, include = FALSE}

# Géométries des communes françaises au 1er janvier 2011 (source : IGN)
geom2011 <- st_read(dsn = "data-raw/geom/COMMUNE.shp")
geom2011 <- geom2011[geom2011$CODE_REG != "94",] # Suppression de la Corse
geom2011 <- st_transform(geom2011, crs = 3035) # Transformation Lambert-93


# Suppression et regroupement des arrondissements de Paris, Lyon et Marseille
arrcom <- read_excel("data-raw/geom/com_arm.xlsx") # Import de la table de passage des arrondissements
com <- merge(geom2011, arrcom, by = "INSEE_COM", all.y = TRUE) # Géométries des arrondissements
com <- aggregate(x = com[,"CODGEO"], by = list(com$CODGEO), # On les aggrège
                   FUN = head, 1)

com$NOM_COMM <- c("MARSEILLE", "LYON", "PARIS")
com$CODE_DEPT <- c("13","69","75")

geom2011 <- geom2011[!geom2011$INSEE_COM %in% arrcom$INSEE_COM, ] # Suppression des arrondissements

colnames(geom2011)[3] <- "CODGEO"
geom2011 <- rbind(geom2011[,c("CODGEO","NOM_COMM", "CODE_DEPT")],
                  com[,c("CODGEO","NOM_COMM", "CODE_DEPT")])


# Agrégation en départements
dep <-  aggregate(x = geom2011[,"CODE_DEPT"], by = list(geom2011$CODE_DEPT), # Agrégation des communes en départements
                   FUN = head, 1)

# Création d'un data frame avec les CODGEO de référence
df <- st_set_geometry(geom2011[,c("CODGEO", "CODE_DEPT")], NULL)

# Forcer character
df$CODGEO <- as.character(df$CODGEO)
df$CODE_DEPT <- as.character(df$CODE_DEPT)

```




## 3.2 - Données statistiques
La jointure des indicateurs contenus dans les tables de référence est réalisée avec les codes communaux 2011, ainsi que les indicateurs d’intérêt INSEE définis dans le Tableau 1 (objet `df2011`).

```{r data_import}

# Importer les tableaux de données d'intérêt
datatmp1 <- data.frame(read_excel("data-raw/stats_insee/base-cc-emploi-pop-active-2009.xls", sheet = "COM_2009", skip = 5))
datatmp2 <- data.frame(read_excel("data-raw/stats_insee/base-cc-evol-struct-pop-2009.xls", sheet = "COM_2009", skip = 5))
datatmp3 <- data.frame(read_excel("data-raw/stats_insee/BTX_FM_DTR_2009.xls", sheet = "TOTAL", skip = 5))
datatmp4 <- data.frame(read_excel("data-raw/stats_insee/Potentiel_financier_2011.xls", sheet = "Rapport1", skip = 2))
datatmp5 <- data.frame(read_excel("data-raw/stats_insee/table-appartenance-geo-communes-11.xls", sheet = "Liste_COM", skip = 5))
datatmp6 <- read.csv("data-raw/stats_insee/city_all.csv", sep = ",", stringsAsFactors = FALSE, fileEncoding = "UTF8")
datatmp6 <- subset(datatmp6, datatmp6$année == "2011")

# Nécessité d'une procédure un peu plus longue pour les données concernant les revenus
# À noter que des messages d'alertes s'affichent mais sans gravité

sheet_names <- excel_sheets("data-raw/stats_insee/Ircom_2011_revenus2010.xls") # On liste les feuilles
datatmp7 <- data.frame()
for (i in 1:length(sheet_names)){
  feuille <- sheet_names[i] # récupère le nom de la feuille
  IRFeuille <- data.frame(read_excel("data-raw/stats_insee/Ircom_2011_revenus2010.xls", sheet = feuille, skip = 20))
  datatmp7 <- rbind(datatmp7, IRFeuille, stringsAsFactors = FALSE)
  rm(feuille, IRFeuille) # suppression des objet intermédiaires
}
# Renommer variables
colnames(datatmp7)[10] <- "Traitements.et.salaires_Nbr.foyers"
colnames(datatmp7)[11] <- "Traitements.et.salaires_Montant"
colnames(datatmp7)[12] <- "Retraites.et.pensions_Nbr.foyers"
colnames(datatmp7)[13] <- "Retraites.et.pensions_Montant"
datatmp7 <- subset(datatmp7, datatmp7$Revenu.fiscal.de.référence.par.tranche..en.euros. == "Total") # Sélection des seules variables totales
datatmp7[, c(5:length(datatmp7))]<- lapply(datatmp7[, c(5:length(datatmp7))], as.numeric) # Variables en numériques
# Création d'un CODGEO
datatmp7$CODGEO <- substr(datatmp7$DÉP, 1, 2)
datatmp7$CODGEO <- paste(datatmp7$CODGEO, datatmp7$Commune, sep = "")

# Jointure avec le champ CODGEO 2011 de référence (issu des géométries)
df <- merge(df, datatmp1, by = "CODGEO", all.x  = TRUE)
df <- merge(df, datatmp2[,c(1, 5:length(datatmp2))], by = "CODGEO", all.x  = TRUE)
df <- merge(df, datatmp3[,c(1, 3:length(datatmp3))], by = "CODGEO", all.x  = TRUE)
df <- merge(df, datatmp4, by.x = "CODGEO", by.y = "Code.INSEE", all.x  = TRUE)
df <- merge(df, datatmp5[,c(1, 5:length(datatmp5))], by = "CODGEO", all.x  = TRUE)
df <- merge(df, datatmp6[,c(5, 12)], by.x = "CODGEO", by.y = "cog..code.officiel.géographique.", all.x = TRUE)
df <- merge(df, datatmp7[,c(5:length(datatmp7))], by = "CODGEO", all.x = TRUE)

# Ne conserver que les indicateurs d'intérêt 
selec <- target$INSEE_CODE
df2011 <- df[,selec]

# Renommer le code des variables
colnames(df2011) <- target$recoding

```

Les catégories du zonage en aires urbaines ont également été regroupées, pour faciliter les analyses de cette typologie. Outre les catégories proposées par l'INSEE (comme l'espace périurbain regroupant les communes codées 112 et 120), des catégories ont été rajoutées comme les communes constituant les petits pôles (codes ZAU 221 et 222) ou les communes hors influence des pôles (300 et 400).

```{r zau_categ}
# Pour créer des catégories plus vastes à partir des 
# Utilisation du ZAU pour cibler les communes appartenant à un petit pôle (unité urbaine et couronne)

# Utilisation du ZAU pour cibler les communes constituant les petits pôles
df2011$ZAU_POL [df2011$CATAEU2010 %in% c("221", "222")] <- "OUI"

# Utilisation du ZAU pour cibler les communes du rural profond
df2011$ZAU_RUR [df2011$CATAEU2010 %in% c("300", "400")] <- "OUI"

# Utilisation du ZAU pour cibler les communes du rural profond + couronnes petits pôles : Marges Sans Pôles
df2011$ZAU_MAR_SP [df2011$CATAEU2010 %in% c("222", "300", "400")] <- "OUI"

# Utilisation du ZAU pour cibler les communes du rural profond + petits pôles et couronnes
df2011$ZAU_MAR [df2011$CATAEU2010 %in% c("221", "222", "300", "400")] <- "OUI"

# Utilisation du ZAU pour cibler les communes périurbaines et les autres
df2011$ZAU_PERI [df2011$CATAEU2010 %in% c("112", "120")] <- "OUI"

# Utilisation du ZAU pour cibler les communes des Grandes aires urbaines, des aires urbaines et les autres
df2011$ZAU_AU [df2011$CATAEU2010 %in% c("111", "112", "120")] <- "GrdAirUrb"
df2011$ZAU_AU [df2011$CATAEU2010 %in% c("211", "212", "221", "222")] <- "AirUrb"
df2011$ZAU_AU [df2011$CATAEU2010 %in% c("300", "400")] <- "Autres"

# Tout ce qui ne fait pas partie des catégories = NON 
selecV <- c("ZAU_POL", "ZAU_RUR", "ZAU_MAR_SP", "ZAU_MAR", "ZAU_PERI", "ZAU_AU")
df2011[selecV][is.na(df2011[selecV])] <- "NON"

# # Si on souhaite, transformation en facteur des catégories des aires urbaines
# df2011$CATAEU2010 <- as.factor(df2011$CATAEU2010)
# df2011$CODGEO <- as.character(df2011$CODGEO)

```



## 3.3 - Fusions communales et communes nouvelles
Afin de créer les informations chronologiques sur les fusions communales, la [table de passage communale](https://www.insee.fr/fr/information/2028028) constitue la source primaire, présentant l’ensemble des mutations qui ont touché des communes en France depuis 2003. Ont également été utilisées les tables mises à disposition par l’INSEE ([un fichier par année depuis 2016](https://www.insee.fr/fr/information/2549968))[^formatdate].

[^formatdate]: Les fichiers Excel fournis par l’INSEE ne sont pas formatés de façon homogène, nécessitant des conversions de format pour les fichiers antérieurs à 2017. Par exemple, les dates sont renseignées au format texte jusqu’à 2017, au format date à partir de 2018. Nous avons préalablement converti les champs date au format texte pour l’ensemble des fichiers. Cela signifie qu’en cas de mise à jour des données ou de modification de l'usage du code par un utilisateur, il faudra de nouveau convertir les dates au format texte au préalable.

Ces informations ont été regroupées au sein d'un seul objet. Si la date d'effet (Date2) était manquante au niveau des données fournies par l'INSEE, on appliquait alors la valeur au 1^er^ janvier de l'année suivante à ce champ (suivant les informations sur les données manquantes dans la documentation des fichiers INSEE disponibles [ici](https://www.insee.fr/fr/information/2549968)).

Cette démarche permettra de compléter aisément le fichier à l’avenir, pour tenir compte des fusions ultérieures : il suffira de rajouter les fichiers les plus récents (dans le dossier `data-raw` comme dans le code pour importer ces derniers) :

* La nouvelle table concernant les fusions de l'année écoulée (2022 par exemple, donc situation au 1^er^ janvier 2023) ;

* La table de passage (s'appelant probablement 2003-2023) ;

* La table d'appartenance (s'appelant probablement 2023)[^maj].

[^maj2022]: Depuis quelques années, la table des fusions de l'année précédente est publiée vers le mois de janvier, celle "de passage" 2003-xxxx et celle des "d'appartenance" quelques semaines après.

```{r import_listes_passages_depuis_2003, echo = FALSE}

# Import de la liste des fusions (cf. plus bas pour l'utilisation)

# comFus <- data.frame(read_excel("data-raw/communes_nouvelles/table_passage_geo2003_geo2020.xlsx", sheet = "Liste des fusions", skip = 5))
# comFus <- data.frame(read_excel("data-raw/communes_nouvelles/table_passage_geo2003_geo2021.xlsx", sheet = "Liste des fusions", skip = 5))
comFus <- data.frame(read_excel("data-raw/communes_nouvelles/table_passage_geo2003_geo2022.xlsx", sheet = "Liste des fusions", skip = 5))


# Import de la liste des scissions (cf. plus bas pour l'utilisation)

# comSci <- data.frame(read_excel("data-raw/communes_nouvelles/table_passage_geo2003_geo2020.xlsx", sheet = "Liste des scissions", skip = 5))
# comSci <- data.frame(read_excel("data-raw/communes_nouvelles/table_passage_geo2003_geo2021.xlsx", sheet = "Liste des scissions", skip = 5))
comSci <- data.frame(read_excel("data-raw/communes_nouvelles/table_passage_geo2003_geo2022.xlsx", sheet = "Liste des scissions", skip = 5))


# Import de la table de passage (cf. plus bas pour l'utilisation)

# modif <- as.data.frame(read_xlsx("data-raw/communes_nouvelles/table_passage_geo2003_geo2020.xlsx", col_types = "text", sheet = "Table de passage", skip = 5))
# modif <- as.data.frame(read_xlsx("data-raw/communes_nouvelles/table_passage_geo2003_geo2021.xlsx", col_types = "text", sheet = "Table de passage", skip = 5))
modif <- as.data.frame(read_xlsx("data-raw/communes_nouvelles/table_passage_geo2003_geo2022.xlsx", col_types = "text", sheet = "Table de passage", skip = 5))
colnames(modif) <- c("CODGEO_INI", "CODGEO_new", "LIBGEO_new" )


# Import de la table d'appartenance de l'année la plus récente (cf. plus bas pour l'utilisation)
# df_new <- data.frame(read_excel("data-raw/stats_insee/table-appartenance-geo-communes-20.xlsx",  sheet = "COM", skip = 5))
# df_new <- data.frame(read_excel("data-raw/stats_insee/table-appartenance-geo-communes-21.xlsx",  sheet = "COM", skip = 5))
df_new <- data.frame(read_excel("data-raw/stats_insee/table-appartenance-geo-communes-22.xlsx",  sheet = "COM", skip = 5))

```



### 3.3.1 - Identification des communes fusionnantes
Nous avons commencé par identifier les communes ayant pris part à une fusion à partir de la table de passage globale fournie par l'INSEE depuis la géométrie de 2003 (cette dernière comporte une page dédiée à ces fusions). Cette table comprend toutes les fusions depuis 2003. Elle comprend donc aussi des fusions de communes qui n'ont pas créé de communes nouvelles, puisque ce statut n'apparaît qu'en 2010 et n'est utilisé pour la première fois qu'en 2012. C'est le sens de la distinction entre le champs `FUSION` créé ici (désignant n'importe quelle fusion de commune) et le champs `COM_NOUV`, créé plus tard, qui concerne bien les seules communes nouvelles.


```{r changes_manip1}


# Pour rappel, comFus est la feuille "Liste des fusions", disponible dans le fichier "table_passage_geo2003-geoxxxx". Elle a été importée plus haut

# Pour éviter les doublons dans la table INSEE
comFus <- aggregate(x = comFus, by = list(comFus$COM_INI), 
                   FUN = head, 1) # On garde le premier élément (car df trié par date)

# Renommer avec la commune fusionnée la plus récente
comFus <- comFus[order(comFus$annee_modif, decreasing = TRUE),]
comFus$LIB_COM_FIN <- ave(comFus$LIB_COM_FIN, comFus$COM_FIN, FUN = function(x) x[1])
comFus <- comFus[,c(2:length(comFus))]

# Identification des communes fusionnantes dans la table d'entrée
df2011 <- merge(df2011, comFus[,c("COM_INI", "annee_modif")], by.x = "CODGEO",
                by.y = "COM_INI", all.x = TRUE)
df2011$annee_modif[!is.na(df2011$annee_modif)] <- "OUI"
df2011$annee_modif[is.na(df2011$annee_modif)] <- "NON"
colnames(df2011)[length(df2011)] <- "FUSION"


```

### 3.3.2 - Identification et caractérisation des communes nouvelles
Les informations contenues dans les tables de passage par années (celles fournies année par année depuis 2016 par l'INSEE et celle créée manuellement pour les fusions ayant eu lieu entre 2012 et 2015) sont ajoutées : elles décrivent des communes créées après l'élaboration du statut de commune nouvelle (par la loi du 16 décembre 2010 intitulée « Loi de réforme des collectivités territoriales ») et sont plus détaillées concernant ces fusions (création ou non de communes déléguées et date de création sont par exemple renseignées)[^notestatut].

[^notestatut]: Le statut de commune nouvelle a été presque unanimement plébiscité. On peut noter le cas jusqu'ici unique de Fontenoy-le-Château (Vosges), commune nouvelle créée au 1^er^ janvier 2013 mais dont la fusion a été transformée en fusion simple.

Certains cas particuliers ont demandé un traitement spécifique :

* Bettoncourt-le-Haut a fusionné en 1972 avec Épizon, sous le statut de commune-associée. Au 1^er^ janvier 2013, avec la création de la commune-nouvelle d'Épizon, la commune de Bettoncourt-le-Haut est devenue commune déléguée. Comme on ne dispose pas des données 2011 pour Bettoncourt-le-Haut, on préfère ignorer cette dernière en considérant que la commune nouvelle d'Épizon est le résultat de la fusion des seules Épizon et Pautaines-Augeville (source : [fiche spécifique de l'INSEE](https://www.insee.fr/fr/metadonnees/cog/commune/COM52046-bettoncourt-le-haut)).

* On doit également traiter individuellement le cas de la commune de L'Oudon, qui a changé de code communal à plusieurs reprises : issue de la fusion-association de dix communes en 1973, elle avait jusqu'en 1990 le code 14472. Du fait d'un transfert de chef-lieu, le code a été modifié en 14697. Après un nouveau transfert de chef-lieu en  2014,  l'INSEE décide en  2016  de  ré-attribuer  le  code de  14472. Cette commune a ensuite fusionné au 1^er^ janvier 2017 au sein de la commune nouvelle de Saint-Pierre-en-Auge. Pour éviter les problèmes d'associations entre les données, nous avons laissé l'ancien code 14697, qui est celui utilisé dans les données INSEE que nous utilisons (millésime 2011).

Pour faciliter la lecture des dynamiques, et sans empêcher néanmoins l'étude par date précise (année, cf. graphique 1 dans la section 4, voire mois et jour), nous distinguons plusieurs vagues de fusions en fonction de leur intensité : une première, concernant 73 communes (se regroupant en 26 communes nouvelles), entre le 1^er^ janvier 2011 et le 1^er^ janvier 2015 inclus, conduit à rassembler ces communes. Ensuite, le nombre plus important de fusions conduit à isoler chaque année 2015, 2016, 2017 et 2018. Enfin, une période de fusions moins nombreuses nous a conduit à réunir les années 2019, 2020 et 2021 (jusqu'au 1er janvier 2022). Cette périodisation pourra être modifiée en fonction d'évolutions les prochaines années (la poursuite des fusions est probable).

```{r changes_manip2}

# Import tables de référence INSEE
tmp <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2012_2014.xls", sheet = "Communes_nouvelles_2012_2014"))
# Traitement du cas particulier de Bettoncourt-le-Haut et Épizon
tmp <- subset (tmp, DepComA != "52046")

tmp1 <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2015.xls", sheet = "Communes nouvelles 2015"))
tmp1$Date2[is.na(tmp1$Date2)] <- "01/01/2016"

tmp2 <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2016.xls", sheet = "Communes nouvelles 2016"))
tmp2$Date2[is.na(tmp2$Date2)] <- "01/01/2017"

# Traitement du cas particulier de la commune de L'Oudon
# tmp2$DepComA[tmp2$NomCA == "Oudon (L')"] <- "14697"
tmp2$DepComA[tmp2$DepComA == "14472"] <- "14697"

tmp3 <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2017.xls", sheet = "Communes nouvelles 2017"))
tmp3$Date2[is.na(tmp3$Date2)] <- "01/01/2018"

tmp4 <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2018.xls", sheet = "Communes_nouvelles_2018"))
tmp4$Date2[is.na(tmp4$Date2)] <- "01/01/2019"

tmp5 <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2019.xls", sheet = "Communes_nouvelles_2019"))

tmp6 <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2020.xlsx", sheet = "Communes_nouvelles_2020"))
tmp6$Date1 <- format(as.Date(tmp6$Date1, format = "%Y-%m-%d"),"%d/%m/%Y") # Pour mettre la date au même format que les fichiers précédents
tmp6$Date2 <- format(as.Date(tmp6$Date2, format = "%Y-%m-%d"),"%d/%m/%Y") # Pour mettre la date au même format que les fichiers précédents

tmp7 <- data.frame(read_excel("data-raw/communes_nouvelles/communes_nouvelles_2021.xlsx", sheet = "Communes_nouvelles_2021"))
tmp7$Date1 <- format(as.Date(tmp6$Date1, format = "%Y-%m-%d"),"%d/%m/%Y") # Pour mettre la date au même format que les fichiers précédents
tmp7$Date2 <- format(as.Date(tmp6$Date2, format = "%Y-%m-%d"),"%d/%m/%Y") # Pour mettre la date au même format que les fichiers précédents

# Regroupement des colonnes identiques des différents dataframe
comNew <- data.frame()
list_df <- list(tmp, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7)

for(item in list_df){     
  items <- item[, names(tmp)] # La référence sont les noms de colonne du premier fichier
  comNew <- rbind(comNew, items)    

}

# Supprimer lignes qui ne concernent que des commentaires dans la feuille excel importée
comNew <- subset(comNew, comNew$DepComN != "NA")
# test <- dplyr::anti_join(comNew, comNew2) # Si on souhaite identifier ces erreurs

# Reformatage de l'année de fusion
comNew$FusDate <- as.Date(comNew$Date2, tryFormats = "%d/%m/%Y")

# Découpage en phases temporelles de fusion
comNew$FusPhas <- cut(comNew$FusDate, 
                        breaks = as.Date(c("2011-1-1", "2015-1-2", "2016-1-2",
                                           "2017-1-2","2018-1-2", "2019-1-2","2022-1-2")), 
                        labels = c("Phase 1", "Phase 2", "Phase 3", "Phase 4", "Phase 5", "Phase 6"))

# Pour fusions successives et à code DepComA identique, ne conserver que l'élément le plus ancien
comNew <- aggregate(x = comNew, by = list(comNew$DepComA),  # on évite les doublons
                   FUN = head, 1) # On ne garde que le premier élément (comNew trié par ordre chronologique)

# Prise en compte du dernier nom de commune nouvelle
comNew <- comNew[order(comNew$FusDate, decreasing = TRUE),]
comNew$NomCN <- ave(comNew$NomCN, comNew$DepComN, FUN = function(x) x[1])
comNew <- comNew[,c(2:length(comNew))] # Ne garder que les colonnes utiles

# Jointure avec le fichier d'origine
df2011 <- merge(df2011, comNew[,c("DepComA","ChefLieu","ComDLG", "FusDate","FusPhas")],
                by.x = "CODGEO", by.y = "DepComA", all.x = TRUE, all.y = TRUE)

# Identification communes nouvelles
df2011$COM_NOUV[!is.na(df2011$FusPhas)] <- "OUI"
df2011$COM_NOUV[is.na(df2011$FusPhas)] <- "NON"
df2011$FusPhas <- as.character(df2011$FusPhas)


# Pour comparer les données issues de la table générale et celles compilées à partir des tables années par années, on peut créer l'objet suivant :
DiffcomFuscomNew <- dplyr::anti_join(comFus, comNew, by = c("COM_INI" = "DepComA")) 

# Les principales différences sont bien liées à la période plus large de la table générale (prend en compte les fusions avant 2011, qui ne sont pas des communes nouvelles)


```

### 3.3.3 - Gestion des scissions communales
Dans la table de passage, des scissions communales étaient mentionnées. L'étape présentée ici a permis que ces dernières ne soient pas considérées comme des fusions ou des communes nouvelles.

Il faut, là encore, noter un cas particulier : en 2012, la commune de Robert-Magny-Laneuville-à-Rémy (52427) se scinde en Robert-Magny (52427) et Laneuville-à-Rémy (52266). Au 1^er^ janvier 2016, Robert-Magny fusionne avec Montier-en-Der (52331) pour former La Porte du Der (52331). Comme on ne dispose pas des données de recensement en 2011 pour Laneuville-à-Rémy, on préfère ignorer cette scission et cette dernière commune n'apparaîtra donc pas dans notre base de données (source : [fiche spécifique de l'INSEE](https://www.insee.fr/fr/metadonnees/cog/commune/COM52427-robert-magny)).


```{r changes_manip3}

# Objectif : que tout ce qui est scission ne soit pas considéré comme commune nouvelle ou fusion
# Pour rappel, comSci est la feuille "Liste des scissions", disponible dans le fichier "table_passage_geo2003-geoxxxx". Elle a été importée plus haut

# Cas particulier de la commune de Robert-Magny-Laneuville-à-Rémy (52427).
comSci <- subset(comSci, COM_INI != "52427")
comSci <- as.vector(unique(comSci$COM_FIN))

df2011$FUSION [df2011$CODGEO %in% comSci] <- "NON"
df2011$COM_NOUV [df2011$CODGEO %in% comSci] <- "NON"
df2011$ChefLieu [df2011$CODGEO %in% comSci] <- NA
df2011$ComDLG [df2011$CODGEO %in% comSci] <- NA
df2011$FusDate [df2011$CODGEO %in% comSci] <- NA
df2011$FusPhas [df2011$CODGEO %in% comSci] <- NA

df2011$FusDate <- as.character(df2011$FusDate)

```



## 3.4 - Agrégation des indicateurs en version la plus récente et calcul des ratios
Une étape majeure a ensuite été l'agrégation des indicateurs, pour les communes ayant fusionné. Cette agrégation, souvent peu complexe (pour les statistiques de stocks, il s'agit de banales additions des variables décrivant les communes fusionnantes), présente plus de difficultés pour le traitement des ratios.
Pour ce faire, une fonction spécifique, `comix`, a été créée. Elle permet d'agréger les données selon leurs spécificités statistiques. Les données textuelles, si elles ne sont pas identiques, sont concaténées, les variables de stock sont additionnées, les variables de ratio sont pondérées en fonction du dénominateur adapé (indiqué dans les métadonnées, pouvant être la population, le nombre d'actifs, le nombre de foyers etc).


```{r comix, echo = FALSE}

comix <- function(x, xid, app, app.init, app.target, var, var.type, w = NULL, na.rm = FALSE) {
  
  # Supprimer les géométries s'il y en a 
  if (methods::is(x, "sf")){
    x <- st_set_geometry(x, NULL)
    }
  
  # Import table d'appartenance des fusions territoriales
  app <- app
  
  # Jointure table d'entrée - table des fusions territoriales
  x <- merge(x, app[,c(app.init, app.target)], by.x = xid, by.y = app.init, all.x = TRUE)
  

  # Unités non concernées par modifications
  tmp <- aggregate(x[,app.target], by = list(app.target = x[,app.target]), FUN = length)
  tmp <- tmp[tmp$x <= 1,] 
  selecUnit <- tmp$app.target
  intact <- x[x[,app.target] %in% selecUnit, ]
  intact <- intact[, c(app.target, var)] 

  # Unités concernées par une modification
  modif <- x[!x[,app.target]%in% selecUnit, ]
  modif <- modif[, c(app.target, var, w)]
  
  # Gestion des types de variables déclarées 
  tmp <- data.frame(var, var.type, row.names = var)
  txt <- row.names(tmp[tmp$var.type == "text",])
  stock <-  row.names(tmp[tmp$var.type == "stock",])
  ratio <- row.names(tmp[tmp$var.type == "ratio",])
  
  # Si variables de type caractère > concaténation des modalités
  if(length(txt > 0)){
    modif.t <- modif[,c(app.target, txt)]
    
    modif.t <- aggregate(modif.t[, -1],
                         by = list(app.target = modif.t[,app.target]),
                         FUN = function(x) {paste0(unique(x), collapse = "-")})
    names(modif.t) <- c(app.target, txt)
    }

  
  # Si variables de type stock > somme des valeurs
  if(length(stock > 0)){
    
    modif.s <- modif[,c(app.target, stock)]
    modif.s <- aggregate(modif.s[, -1],
                         by = list(app.target = modif.s[,app.target]),
                         FUN = sum, na.rm = na.rm)
    names(modif.s) <- c(app.target, stock)
    }
  

  # Si variables de type ratio > moyenne simple ou pondérée 
  ## Si pas de variable de pondération
  if(length(ratio > 0)){  
    if(is.null(w)){
      modif.r <- modif[,c(app.target, ratio)]
      modif.r <- aggregate(modif.r[, -1],
                           by = list(CODGEO_new = modif.r$CODGEO_new),
                           FUN = mean, na.rm = na.rm)
      }
    
    ## Si pondération... 
    # Commentaire : Avec dplyr, fonctionnement pas très esthétique mais fonctionne.
    # Plusieurs méthodes non concluantes ont été testées (cf sous la fonction)
    else{
      modif.r <- modif[,c(app.target, ratio, w)]
      names(modif.r)[which(names(modif.r) == w)] <- "weight"
      names(modif.r)[which(names(modif.r) == app.target)]  <- "app.target"
      names(modif.r)[which(names(modif.r) %in% ratio)]  <- paste0("ratio",names(modif.r[ratio]))
      
      modif.r <- modif.r %>%                   
        group_by_at(vars(app.target)) %>% 
        summarise_at(vars(starts_with('ratio')), list(~weighted.mean(., weight, na.rm = na.rm)))  
        modif.r <- as.data.frame(modif.r)
        }
    
    names(modif.r) <- c(app.target, ratio)
  }
  
  # Union des 3 types de variables - 8 cas de figure
  # Commentaire : pas trouvé la solution du type if(exists("x")), cbind(x)
  if(exists("modif.t") == FALSE & exists("modif.s") == FALSE & exists("modif.r") == FALSE ){
    stop("Define at least one var combined to one var.type", call. = FALSE)
  }
  
  if(exists("modif.t") == TRUE & exists("modif.s") == TRUE & exists("modif.r") == TRUE ){
    modif <- cbind(modif.t, modif.s, modif.r) 
  }
  
  if(exists("modif.t") == FALSE & exists("modif.s") == TRUE & exists("modif.r") == TRUE ){
    modif <- cbind(modif.s, modif.r) 
  }
  
  if(exists("modif.t") == TRUE & exists("modif.s") == FALSE & exists("modif.r") == TRUE){
    modif <- cbind(modif.t, modif.r) 
  }
  
  if(exists("modif.t") == TRUE & exists("modif.s") == TRUE & exists("modif.r") == FALSE){
    modif <- cbind(modif.t, modif.s) 
  }
  
  if(exists("modif.t") == TRUE & exists("modif.s") == FALSE & exists("modif.r") == FALSE){
    modif <- modif.t
  }
  
  if(exists("modif.t") == FALSE & exists("modif.s") == TRUE & exists("modif.r") == FALSE){
    modif <- modif.s
  }
  
  if(exists("modif.t") == FALSE & exists("modif.s") == FALSE & exists("modif.r") == TRUE){
    modif <- modif.r
  }
  


  # Liaison avec les unités territoriales inchangées
  x <- rbind(intact, modif[,names(intact)])
  
  return(x)
  }
```


Nous avons, au préalable, importé les zonages de référence pour l'année la plus récente (2021), ce qui permet d'avoir les informations les plus à jour possible (cas de quelques communes ayant changé de département avec les fusions). Ce sont ces zonages qui constituent le matériau de base de l'objet `df_new`.

```{r data_ref_comnew}


# Pour rappel, df_new est la table d'appartenance à l'année la plus récente. Elle a été importée plus haut.

df_new <- df_new[,c("CODGEO","LIBGEO","DEP","REG")] # NB : certains éléments ne sont plus dans les données à partir de 2021 : "CATAEU2010","AU2010", "EPCI"... Ont donc été supprimées. Il faudra songer à intégrer le nouveau zonage lorsqu'il sera disponible. Ci-dessous, commenté, le code qui servait à l'intégration des données jusqu'en 2020

# df_new <- df_new[,c("CODGEO","LIBGEO","DEP","REG","CATAEU2010","AU2010","EPCI")]
# colnames(df_new)[1:3] <- c("CODGEO_new","LIBGEO_new","CODE_DEPT") 
# # Création catégories
# df_new$ZAU_POL [df_new$CATAEU2010 %in% c("221", "222")] <- "OUI"
# df_new$ZAU_RUR [df_new$CATAEU2010 %in% c("300", "400")] <- "OUI"
# df_new$ZAU_MAR_SP [df_new$CATAEU2010 %in% c("222", "300", "400")] <- "OUI"
# df_new$ZAU_MAR [df_new$CATAEU2010 %in% c("221", "222", "300", "400")] <- "OUI"
# df_new$ZAU_PERI [df_new$CATAEU2010 %in% c("112", "120")] <- "OUI"
# df_new$ZAU_AU [df_new$CATAEU2010 %in% c("111", "112", "120")] <- "GrdAirUrb"
# df_new$ZAU_AU [df_new$CATAEU2010 %in% c("211", "212", "221", "222")] <- "AirUrb"
# df_new$ZAU_AU [df_new$CATAEU2010 %in% c("300", "400")] <- "Autres"
# # Tout ce qui ne fait pas partie des catégories = NON 
# selecV <- c("ZAU_POL", "ZAU_RUR", "ZAU_MAR_SP", "ZAU_MAR", "ZAU_PERI", "ZAU_AU")
# df_new[selecV][is.na(df_new[selecV])] <- "NON"


colnames(df_new) <- c("CODGEO_new","LIBGEO_new","CODE_DEPT_new", "REG_new") 



```


```{r data_aggreg}

# Nous utilisons ici la fonction `comix` pour agréger les données d'intérêt en fonction de la géographie la plus récente (ici, au 1^er^ janvier 2021). La table `df_new` ainsi créée nous permet donc, pour chaque variable choisie (stock et ratio), de disposer des données pour les entités à la géométrie la plus récente.


# Agrégation des données de 2011 vers l'année la plus récente (stock + texte)
# Import de la table de passage : "modif"
# Pour rappel, modif est la feuille "Table de passage", disponible dans le fichier "table_passage_geo2003-geoxxxx". Elle a été importée plus haut

# Agrégation
# Attention à bien indiquer la nature pour chaque variable visée 
tmp <- comix(x = df2011, xid = "CODGEO", app = modif,
                app.init = "CODGEO_INI", app.target = "CODGEO_new", 
                var = c(target$recoding, "FUSION", "FusDate", "FusPhas", "COM_NOUV"),
                var.type = c(target$type_variable, rep("text",4)))


# Gestion des "OUI-NON" > transformé en "OUI"
selec <- c("FUSION", "COM_NOUV")
tmp[,selec][tmp[,selec] == "OUI-NON"] <- "OUI"
tmp[,selec][tmp[,selec] == "NON-OUI"] <- "OUI"

# Jointure avec le fichier de référence le plus récent
df_new <- merge(df_new, tmp, by.x = "CODGEO_new", by.y = "CODGEO_new",
                all.x = TRUE)

# Suppression des territoires corses, des DOM et des communes associées (pas de geom)
depsuppr <- c("94","01","02","03","04","06")
df_new <- df_new[!df_new$REG %in% depsuppr,] 
df_new <- df_new[!is.na(df_new$CODGEO),]


# Jointure des codes géographiques récents pour df2011
df2011 <- merge(df2011, modif, by.x = "CODGEO", by.y = "CODGEO_INI", all.x = TRUE)

# Gestion des chefs-lieux dans les fusions successives
# Suppression des chefs lieux des communes ayant fusionné a posteriori
df2011$ChefLieu <- ifelse(df2011$CODGEO == df2011$CODGEO_new, "O", "N")

# Transformation en factor d'un champ
#df_new$CATAEU2010 <- as.factor(df_new$CATAEU2010) # Ne sont plus dans les données à partir de 2021
df2011$CATAEU2010 <- as.factor(df2011$CATAEU2010)

```



```{r ratios}

ratio_tt <- as.data.frame(read_excel("data-raw/meta.xlsx", sheet = "ratios"))
# Comme pour les variables, seuls certains ratios sont sélectionnés
ratio <- subset(ratio_tt, variable_selec == "X")

# Compilation des ratios pour les communes 2011
for (i in 1:nrow(ratio)){
  df2011[paste0(ratio[i,"CODE"])] <- (df2011[[ratio[i, "Numerator_Code"]]] / 
    df2011[[ratio[i, "Denominator_Code"]]]) * ratio[i,"Coeff"]
}

# Compilation des ratios pour les communes à la dernière géométrie connue
for (i in 1:nrow(ratio)){
  df_new[paste0(ratio[i,"CODE"])] <- (df_new[[ratio[i, "Numerator_Code"]]] / 
    df_new[[ratio[i, "Denominator_Code"]]]) * ratio[i,"Coeff"]
}

```

```{r date_fusion_ini}
# On précise ici la date de la fusion du chef-lieu, qui est en général la date de la première fusion dans le cas de fusions successives
df_new <- merge(df_new, df2011[, c("CODGEO", "FusDate", "FusPhas")], by.x = "CODGEO_new", by.y = "CODGEO", all.x = TRUE, suffixes = c("", "_ChefLieu"))

```



## 3.5 - Résumé des indicateurs disponibles par fichier de données de référence

Deux jeux de données ont ainsi été produits :

* Le premier, `df2011`, contient l'ensemble des données communales françaises désirées en fonction de la géographie administrative au 1^er^ janvier 2011.

* Le second, `df_new`, contient les informations en fonction de la géographie administrative du 1^er^ janvier de la dernière année pour laquelle les données ont été publiées par l'INSEE. Les données 2011 ont été regroupées en fonction du fichier des fusions délivré par l'INSEE, à l'aide de la fonction `comix` créée plus haut. Le tableau 3 détaille les codes respectifs que ces fichiers contiennent, ainsi qu'un descriptif de leur contenu.

```{r meta_df2011, echo = FALSE}

codes <- names(df2011)
nums <- target$DESCRIPTION

zau <- c("Petit pôle et couronne de petits pôles (catégories 221 et 222 du zonage en aires urbaines (OUI/NON)",
         "Communes rurales et autres (catégories 300 et 400 du zonage en aires urbaines (OUI/NON)",
         "Marges sans pôles (catégories 222, 300 ey 400 du zonage en aires urbaines (OUI/NON)",
         "Rural profond + petits pôles et couronnes (catégories 221, 222, 300 et 400 du zonage en aires urbaines (OUI/NON)",
         "Périurbain de grands pôles (catégories 112 et 120 du zonage en aires urbaines (OUI/NON)",
         "Typologie regroupée basées sur les aires urbaines : GrdAirUrb (catégories 111, 112, 120), AirUrb (211, 212, 221, 222) et Autres (300, 400)")
change <- c(
            "Est-ce que la commune a fusionné entre 2011 et aujourd'hui (OUI/NON)",
            "Commune nouvelle : Statut de commune chef-lieu (O=OUI, N=NON)",
            "Commune nouvelle : Statut de Commune déléguée (O=OUI, N=NON)",
            "Date d'effet de la création de commune nouvelle",
            "Phase dans le processus de fusion (phase 1 = 2011-2015, 2 = 2015-2016, 3 = 2016-2017, 4 = 2017-2018, 5 = 2018-2020, 6 = 2020-2021",
            "Est que la commune est devenue une commune nouvelle (OUI/NON)",
            "Code INSEE, découpage géographique le plus récent",
            "Nom de la commune, découpage géographique le plus récent")

rates <- ratio$DESCRIPTION

label <- c(nums, zau, change, rates)
tab <- data.frame(codes, label)
colnames(tab) <- c("Codes", "Description")
# knitr::kable(tab, row.names = F) # Pour export html
ft <- flextable(tab)
ft <- set_caption(ft, caption = "Tableau 3 : Les variables présentes dans la base de données")
ft <- width(ft, width = 4)
ft
```


Les variables présentes dans `df_new` sont identifiées de la même manière que dans `df2011`. Les seules différences concernent les identifiants des communes (on rajoute "_new" pour distinguer les CODGEO et les noms des communes à la nouvelle géométrie) et la suppression de champs n'ayant de sens que pour les communes fusionnantes, qui n'existent donc pas [^notevariablesfusionnantes].

[^notevariablesfusionnantes]: Les variables dédiées aux chefs-lieux et aux communes déléguées (codes `ChefLieu` et `ComDLG`) ne sont pas inclues dans le jeu de données aux géographies récentes, car non adaptées à ce niveau de granularité géographique.

Les jeux de données de référence ont finalement été exportés dans le dossier `data` au format RData. 

```{r export_data}
# Trois lignes ci-desssous pour créer le dossier nécessaire à l'accueil des données créées
# setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # On définit le dossier en cours comme répertoire de travail
# getwd() # Pour vérification
# dir.create("data") # création du dossier destiné à accueillir les données créées

try(save(df2011, df_new, file = "data/refdata.Rdata"))

```

## 3.6 - Agrégation des dernières géométries connues (2021), extraction des communes nouvelles et export des résultats
Après le travail sur les données, ce sont les géométries qui ont été agrégées pour correspondre aux géométries les plus récentes (ici, 1^er^ janvier 2021). Des objets ont ensuite été spécifiquement créés pour isoler et permettre de faciliter l'étude des communes fusionnantes (`geomfus2011`) et des communes nouvelles (`geomCN_new`).

```{r geom_aggreg}

# Communes françaises au 1er janvier 2011
geom2011 <- geom2011[,c("CODGEO")]

# Communes françaises à la géométrie la plus récente
geom_new <- merge(geom2011, df2011[,c("CODGEO","CODGEO_new")])
geom_new <- aggregate(x = geom_new[,"CODGEO_new"], 
                      by = list(geom_new$CODGEO_new), FUN = head, 1)
geom_new <- geom_new[,c("CODGEO_new")]


# Communes nouvelles avant et après fusion
geomfus2011 <- merge(geom2011, df2011[,c("CODGEO", "COM_NOUV")])
geomCN_new <- merge(geom_new, df_new[,c("CODGEO_new", "COM_NOUV")])

geomfus2011 <- geomfus2011[geomfus2011$COM_NOUV == "OUI",]
geomfus2011 <- geomfus2011[,c("CODGEO")]
geomCN_new <- geomCN_new[geomCN_new$COM_NOUV == "OUI",]
geomCN_new <- geomCN_new[,c("CODGEO_new")]

```

Cinq couches géographiques ont été exportées dans le fichier `geom.gpkg` (au sein du dossier "data", *cf.* Figure 1) :

* Les géométries communales au 1^er^ janvier 2011 (`geom2011`).

* Les géométries communales au 1^er^ janvier de l'année la plus récente pour laquelle des données ont été publiées par l'INSEE (2021) (`geom_new`).

* Les géométries des communes concernées par une création de communes nouvelles, avant fusion (`geomfus2011`).

* Les géométries des communes nouvelles, après fusion (`geomCN_new`).

* Une couche d'habillage pour les représentations cartographiques : les départements (`dep`).


```{r geom_export}
# Export des fichiers consolidés
st_write(obj = geom2011, dsn = "data/geom.gpkg", layer = "geom2011", delete_layer = TRUE, quiet = TRUE)
st_write(obj = geom_new, dsn = "data/geom.gpkg", layer = "geom_new", delete_layer = TRUE, quiet = TRUE)
st_write(obj = geomfus2011, dsn = "data/geom.gpkg", layer = "geomfus2011", delete_layer = TRUE, quiet = TRUE)
st_write(obj = geomCN_new, dsn = "data/geom.gpkg", layer = "geomCN_new", delete_layer = TRUE, quiet = TRUE)
st_write(obj = dep, dsn = "data/geom.gpkg", layer = "dep", 
         delete_layer = TRUE, quiet = TRUE)
```



# 4 - Traitements possibles
Nous proposons ici quelques exemples de traitements rendus possibles par la base de données ainsi constituée.

## 4.1 - La création des communes nouvelles au cours du temps
Un premier type d’analyse consiste à produire une vision chronologique des créations de communes nouvelles. On propose ici une visualisation du nombre de communes fusionnantes ayant rejoint une commune nouvelle pour une année donnée (on a plusieurs cas de fusions successives). Le graphique 1 analyse le nombre de communes fusionnantes en fonction de l'année de la fusion (dans ce graphique, comme dans les tables de l'INSEE, les fusions effectives au 1^er^ janvier d'une année *n* sont notées à l'année *n-1*). Il permet de relever les différentes périodes identifiées en six phases (*cf.* plus haut). Cette répartition peut être cartographiée (Figure 2), en fonction de ces phases. Des développements possibles peuvent consister à comparer les données de manière diachronique.

```{r traitement_graph_annee}

datafus2011 <- subset(df2011, COM_NOUV == "OUI") # Désigne les données concernant les communes ayant participé à la création d'une commune nouvelle, appelées ici communes fusionnantes

datafus2011$FusDate <- as.Date(datafus2011$FusDate, tryFormats = "%Y-%m-%d")

datafus2011$FusDatenee <- cut(datafus2011$FusDate, 
                        breaks = as.Date(c("2011-1-1", "2012-1-2", "2013-1-2", "2014-1-2", "2015-1-2", "2016-1-2",
                                           "2017-1-2","2018-1-2", "2019-1-2", "2020-1-2", "2021-1-2")), 
                        labels = c("2011", "2012", "2013", "2014", "2015", "2016", "2017", "2018", "2019", "2020")) # NB : On intègre le 1er janvier d'une année n à l'année précédente

time_serie <- data.frame(table(datafus2011$FusDatenee))

barplot(time_serie$Freq,  xlab = " ", ylab = "Nombre de communes fusionnantes",
        main = " ",# "Graphique 1 :\nNombre de communes fusionnantes\nen fonction de l'année de fusion",
        ylim = c(0, 2000), names.arg = time_serie$Var1)
grid(nx=0, ny = 10, col="gray", lwd=2)

```

**Graphique 1 : Nombre de communes fusionnantes en fonction de l'année de fusion**

```{r traitement_carte_comm_annee}

geomfus2011 <- merge(geomfus2011, datafus2011, by = "CODGEO") # jointure données/géométries

col <- c("#a50026","#d73027","#f46d43","#fdae61","#fee090", "#ffffbf") # Échelle rouge vers le plus clair


svg("figures/Communes fusionnantes (2012-2021) par phases.svg")

plot(st_geometry(dep), border = "#1A1A19", col = "white", lwd = 1)
typoLayer(x = geomfus2011, var = "FusPhas",  
          col=col,
          border = NA, 
          legend.title.cex = 0.7,
          legend.values.cex = 0.6,
          legend.title.txt = " ",
          legend.pos = "left", 
          legend.values.order = c("Phase 1", "Phase 2", "Phase 3", "Phase 4", "Phase 5", "Phase 6"),
          add = T)

layoutLayer(title = " ", # "Figure 2 : Communes fusionnantes (2012-2021) par phases",
            author = "G. Bideau et R. Ysebaert",
            tabtitle = TRUE, frame = FALSE, col = "white", coltitle = "black",
            sources = "Sources : INSEE, IGN, 2021")
dev.off()
```

![**Figure 2 : Communes fusionnantes (2012-2021) par phases**](figures/Communes fusionnantes (2012-2021) par phases.svg)


## 4.2 - Communes fusionnantes et zonage en aire urbaine
À partir du zonage en aire urbaine INSEE de chaque commune (CATAEU2010), il est également possible d’analyser globalement le profil des communes fusionnantes en le comparant à celui des communes inchangées.

Les modalités agrégées correspondent aux définitions des zonages en aire urbaines sont, pour référence : 

* 111 : Commune appartenant à un grand pôle (10 000 emplois ou plus)
* 112 : Commune appartenant à la couronne d'un grand pôle
* 120 : Commune multipolarisée des grandes aires urbaines
* 211 : Commune appartenant à un moyen pôle (5 000 à moins de 10 000 emplois)
* 212 : Commune appartenant à la couronne d'un moyen pôle
* 221 : Commune appartenant à un petit pôle (de 1 500 à moins de 5 000 emplois)
* 222 : Commune appartenant à la couronne d'un petit pôle
* 300 : Autre commune multipolarisée
* 400 : Commune isolée hors influence des pôles


```{r traitement_graph_ZAU}
dataNfus2011 <- subset(df2011, COM_NOUV == "NON") # Les communes, à la géométrie 2011, qui n'ont pas participé à la création d'une commune nouvelle

ZAU_non <- data.frame(dataNfus2011$CATAEU2010)
ZAU_oui <- data.frame(datafus2011$CATAEU2010)

ZAU_non$Fusion <- "Communes inchangées"
ZAU_oui$Fusion <- "Communes fusionnantes"

colnames(ZAU_non)[1] <- "CATAEU2010"
colnames(ZAU_oui)[1] <- "CATAEU2010"

ZAU <- rbind(ZAU_oui, ZAU_non)

ZAU <- table(ZAU$Fusion, ZAU$CATAEU2010)

prop <- prop.table(ZAU, 1) * 100

barplot(prop,
        xlab = "Catégories d'aire urbaine",
        ylab = "Part du total des communes (%)",
        # names.arg = c("Commune appartenant à un grand pôle", "Commune appartenant à la couronne d'un grand pôle", " Commune multipolarisée des grandes aires urbaines", "Commune appartenant à un moyen pôle", " Commune appartenant à la couronne d'un moyen pôle", "Commune appartenant à un petit pôle", "Commune appartenant à la couronne d'un petit pôle", "Autre commune multipolarisée", "Commune isolée hors influence des pôles"), 
        main = " ",# "Graphique 2 :\nRépartition des communes fusionnantes ou non\nen fonction des catégories d'aire urbaine",
        las = 2,
        border = NA,
        col=c("#ff87a9","#f7d358"),
        beside = TRUE)

legend(x="topright", legend = rownames(prop) , cex=0.8,
       fill=c("#ff87a9","#f7d358"),bty="n")     

tab.chi2 <- chisq.test(ZAU)
```

**Graphique 2 : Répartition des communes fusionnantes ou non en fonction des catégories d'aire urbaine**

Ainsi, les profils des communes fusionnantes et des communes inchangées sont relativement proches. Les écarts les plus importants se situent aux extrêmes. Les communes fusionnantes sont marquées par une plus faible représentation des communes centres de grands ou moyens pôles dans les communes nouvelles et une sur-représentation des communes multipolarisées ou hors influence des pôles. Un test du Chi² permet de rejeter l’hypothèse d’indépendance des deux variables (X² = `r tab.chi2$statistic`, df = `r tab.chi2$parameter` et p-value = `r tab.chi2$p.value`).


D'autres traitements sont évidemment possibles avec la base de données réalisée, comme par exemple l'élaboration d'une typologie à l'aide d'une Classification par Ascendance Hiérarchique (CAH), qui a été réalisée pour les communes créées entre 2012 et le 1^er^ janvier 2020 [@auteurAparaitre].

## 4.3 - La répartition des communes fusionnantes par départements

La question de la taille des communes est un enjeu majeur de l'analyse des communes nouvelles. En effet, cette dernière paraît être un facteur explicatif assez intuitif. Or une carte avec une trame départemental permet de très rapidement observer une fréquente déconnexion entre les territoires accueillant de très nombreuses petites communes et les espaces ayant connu de nombreuses créations de communes nouvelles. Les départements de forts taux de communes de moins de 1000 habitants ne sont ainsi pas forcément ceux où des communes ont fusionné en grand nombre. Cela signifie que le mouvement des communes nouvelles ne règle pas du tout la question des petites communes dans nombre de départements, alors que c'est un des objectifs avancés par la loi.


```{r Variables_departements, eval = TRUE, echo = FALSE}

dataCN_new <- subset(df_new, COM_NOUV == "OUI") # Les  communes nouvelles, avec les géométries au 1er janvier 2021 et caractérisées par les données à la géométrie 2011 agrégées.

# Nombre de fusions par département
FusionsDep<-data.frame(table(dataCN_new$CODE_DEPT))
colnames(FusionsDep)<-c("CODE_DEPT", "NbrFusions")
depart <- data.frame(table(df2011$CODE_DEPT))
colnames(depart)<-c("CODE_DEPT", "NbrCom2011")
FusionsDep<-merge(FusionsDep, depart, by = "CODE_DEPT", all.y = TRUE) # Fusion avec une table comprenant tous les départements
FusionsDep$NbrFusions[is.na(FusionsDep$NbrFusions)] <- 0


# Nombre de communes fusionnées par département ?
NbrComFusDep <- data.frame(table(datafus2011$CODE_DEPT))
colnames(NbrComFusDep)<-c("CODE_DEPT", "NbrComFus")

FusionsDep <- merge(FusionsDep, NbrComFusDep, by = "CODE_DEPT", all = TRUE)


# Calcul nombre de communes dans chaque département en 2011 (Av) et en 2021 (Ap)
temp<-data.frame(table(df_new$CODE_DEPT))
colnames(temp)<-c("CODE_DEPT", "NbrComAp")
FusionsDep<-merge(FusionsDep, temp, by = "CODE_DEPT") # Fusion avec la table complète sur les départements

temp<-data.frame(table(df2011$CODE_DEPT))
colnames(temp)<-c("CODE_DEPT", "NbrComAv")
FusionsDep<-merge(FusionsDep, temp, by = "CODE_DEPT") # Fusion avec la table complète sur les départements


# Création de statistiques, ici nombre de communes par rapport à des seuils choisis
# Ici communes sous le seuil de 1000 habitants

listeSeuils <- c(50, 100, 200, 500, 1000)

results <- FusionsDep[, c("CODE_DEPT", "NbrComAv", "NbrComAp")]

for (i in listeSeuils) {
temp <- subset(df2011, df2011$P09_POP < i)
temp<-data.frame(table(temp$CODE_DEPT))
colnames(temp)<-c("CODE_DEPT", paste0("ComMoins", i, "habAv"))

temp2 <- subset(df_new, df_new$P09_POP < i)
temp2<-data.frame(table(temp2$CODE_DEPT))
colnames(temp2)<-c("CODE_DEPT", paste0("ComMoins", i, "habAp"))

results <- merge(results, temp, by = "CODE_DEPT", all.x = TRUE)
results <- merge(results, temp2, by = "CODE_DEPT", all.x = TRUE)

results[, paste0("PartComMoins", i, "habAv")] = round((results[, paste0("ComMoins", i, "habAv")] /
                                                        results$NbrComAv *100), 1)
results[, paste0("PartComMoins", i, "habAp")] = round((results[, paste0("ComMoins", i, "habAp")] /
                                                        results$NbrComAp *100), 1)

results[, paste0("EvolNbrComMoins", i, "hab")] = results[, paste0("ComMoins", i, "habAp")] -
  results[, paste0("ComMoins", i, "habAv")] # Calcul de l'évolution en valeur absolue

results[, paste0("EvolComMoins", i, "hab")] =
  round((
  (results[, paste0("ComMoins", i, "habAp")] - results[, paste0("ComMoins", i, "habAv")]) /
    results[, paste0("ComMoins", i, "habAv")] *100), 1) # Calcul du pourcentage d'évolutions du nombre de communes sous le seuil i

results[, paste0("EvolPartComMoins", i, "hab")] =
  round((
  (results[, paste0("PartComMoins", i, "habAp")] - results[, paste0("PartComMoins", i, "habAv")]) / results[, paste0("PartComMoins", i, "habAv")]*100), 1) # calcul de l'évolution de la part des communes sous le seuil i

# Pour calculer le nombre de communes sous le seuil i ayant fusionné
temp3 <- subset(df2011, df2011$P09_POP < i & FUSION == "OUI")
temp3 <- data.frame(table(temp3$CODE_DEPT))
colnames(temp3)<-c("CODE_DEPT", paste0("ComFusMoins", i, "hab"))
results <- merge(results, temp3, by = "CODE_DEPT", all.x = TRUE)

rm(temp, temp2, temp3)
}


FusionsDep <- merge(FusionsDep, results[, c(1, 4:length(results))], by = "CODE_DEPT", all.x = TRUE)
FusionsDep[is.na(FusionsDep)] <- 0 
```

```{r traitement_carte_petitescomm, eval = FALSE}

ShpDep <- as(dep, "Spatial")

svg("figures/Communes nouvelles et petites communes (2012-2021).svg")
# Carte départementale sur communes de moins de 1000 habitants et nombre de fusions

# Carte choroplèthe en fonction du pourcentage de communes de moins de 1000 habitants
choroLayer(spdf = ShpDep, # SpatialPolygonsDataFrame
           df = FusionsDep, # data frame
           spdfid = "CODE_DEPT",
           dfid = "CODE_DEPT",
           var = "PartComMoins1000habAv",
           # Si on souhaite faire les groupes manuellement :
           # breaks = c(0,0.27,5,10, 37), # liste des seuils (hypothèses)
           # col = carto.pal(pal1 = "turquoise.pal", n1 = 6, pal2 = "blue.pal", n2 = 0),
           # Si on souhaite avoir des groupes par quantiles :
           col = carto.pal(pal1 = "red.pal", n1 = 4), method = "quantile",
           nclass = 4,
           add=FALSE,
           legend.pos = "topleft", 
           legend.title.txt = "Pourcentage de communes\nde moins de 1000 habitants")
# On rajoute les cercles en fonction du nombre de communes de moins de 1000 habitants
propSymbolsLayer(spdf = ShpDep, # Ou à la place on peut utiliser "spdf = Communesfus" créé plus haut
                 df = FusionsDep,
                 spdfid = "CODE_DEPT",
                 dfid = "CODE_DEPT",
                 var = "ComMoins1000habAv",
                 inches = 0.2, fixmax = max(FusionsDep$ComMoins1000habAv),
                 #breakval = 3, # On précise une valeur tournant
                 symbols = "circle", 
                 col = "grey",
                 #col2 = "red",
                 legend.pos = "bottomleft",
                 #legend.pos = "right"
                 #legend.title.txt = "\n\n\n\n\nNombre de\ncommunes\nde moins de\n1000 habitants",
                 legend.title.txt = "Communes\nde moins de\n1000 habitants",
                 legend.style = "c",
                 legend.frame = FALSE,
                 add = TRUE)
# On rajoute les cercles en fonction du nombre de communes ayant fusionné
propSymbolsLayer(spdf = ShpDep, # Ou à la place on peut utiliser "spdf = Communesfus" créé plus haut
                 df = FusionsDep,
                 spdfid = "CODE_DEPT",
                 dfid = "CODE_DEPT",
                 var = "NbrComFus",
                 inches = 0.2, fixmax = max(FusionsDep$ComMoins1000habAv),
                 #breakval = 3, # On précise une valeur tournant
                 symbols = "circle",
                 col = "blue",
                 #col2 = "red",
                 legend.pos = "left",
                # legend.title.txt = "\n\nNombre de\ncommunes\nayant participé à la\ncréation d'une\ncommune nouvelle",
                 legend.title.txt = "\nCommunes\nfusionnantes",
                 legend.style = "c",
                 legend.frame = FALSE,
                 add = TRUE)
layoutLayer(title = "Communes nouvelles et petites communes par départements (2012-2021)", coltitle = "black",
            sources = "                                 Source : INSEE, IGN, 2021", scale = NULL,
            author = "                                  Auteur : G. Bideau et R. Ysebaert", frame ="", col = NA, postitle = "center")
dev.off()

```

![**Figure 3 : Communes nouvelles et petites communes (2012-2021)**](figures/Communes nouvelles et petites communes (2012-2021).svg)


# Conclusion
La base de données *DAC (Données Agrégées des Communes) 2011-2021* permet une analyse approfondie du phénomène des communes nouvelles. Qu'il s'agisse de décrire les entités y ayant participé (les communes fusionnantes), les nouvelles entités créées (les communes nouvelles) ou les transformations qu'impliquent la fusion, de nombreuses études sont possibles, au-delà des premières approches qui ont pu être proposées à l'aide de cette base [@bideau2019 ; @bideau2022 ; @bideauAparaitre].


Au-delà de la question des communes nouvelles, les regroupements d'entités géographiques se retrouvent à de multiples échelles. L’analyse de ces derniers pourra être facilitée par les éléments de reproductibilité et d’intégration de nouvelles données annuelles, en fonction des évolutions des fusions. *A posteriori* ou *a priori*, les décisions politiques gagneront toujours à une évaluation ouverte et transparente de leurs conséquences.




# Bibliographie
